#!/bin/bash

unset _CACHE_PACKAGE_LOCAL _CACHE_PACKAGE_GLOBAL _DEBUG_DEPENDS_LIST _DEBUG_PACKAGE_LIST

. ${ROOT}/devices/options ""

${CONFIG}/tools/checkdeps || exit 1

# Setup both toolchain cmake configs to avoid potentially racy behaviour later.
# Use a fork for host to isolate any variable modifications.
(setup_toolchain host)
setup_toolchain target

# Display distribution configuration
check_config
set_build
#show_config
echo -e "\n\n> Process started.."

# Collect versioning details
echo -e ">> Reading versioning details.."
GIT_HASH=$(git rev-parse HEAD)
GIT_ABBREV=${GIT_HASH:0:7}
case "${DISTRO_STATUS}" in
	nightly)
		DISTRO_CODE=${DISTRO_STATUS}-$(date +%Y%m%d)-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	daily)
		DISTRO_CODE=${DISTRO_STATUS}-$(date +%Y%j)-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	weekly)
		DISTRO_CODE=${DISTRO_STATUS}-$(date +%G%V)-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	monthly)
		DISTRO_CODE=${DISTRO_STATUS}-$(date +%Y%m)-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	devel)
		DISTRO_CODE=${DISTRO_STATUS}-$(date +%Y%m%d%H%M%S)-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	stable)
		DISTRO_CODE=${DISTRO_STATUS}-${GIT_ABBREV}
		DISTRO_LABEL="(${DISTRO_CODE})"
		;;
	*)
		DISTRO_CODE=${DISTRO_STATUS}
		DISTRO_LABEL="${DISTRO_CODE}"
		;;
esac

TARGET_VERSION="${DEVICE}.${TARGET_ARCH}-${DISTRO_CODE}"
IMAGE_NAME="${DISTRO_NAME}-${DISTRO_VERSION}-${TARGET_VERSION}"

# Setup fakeroot
echo ">> Building fake root.."
rm -rf ${FAKEROOT_SCRIPT}   # remove ${FAKEROOT_SCRIPT} if it exist
touch ${FAKEROOT_SCRIPT}    # create an empty ${FAKEROOT_SCRIPT}
chmod +x ${FAKEROOT_SCRIPT} # make ${FAKEROOT_SCRIPT} executable
echo "chown -R 0:0 ${INSTALL}" >>${FAKEROOT_SCRIPT}

# Clean old install dirs
rm -rf ${INSTALL}
rm -rf ${INSTALL_STAMPS}
mkdir -p ${INSTALL}

# Create base layout of Clue read-only file system
echo ">> Creating base layout of read-only file system.."
for directory in etc dev proc run sys tmp usr var boot home; do
	mkdir -p ${INSTALL}/${directory}
done

python ${CONFIG}/tools/jsongen.py --device="${DEVICE}" --distroname="${DISTRO_NAME}" --distrostatus="${DISTRO_STATUS}" \
						--distroversion="${DISTRO_VERSION}"  --distroprovider="${DISTRO_PROVIDER}"  \
						--distrodescription="${DISTRO_LONGNAME}" --distrocode="${DISTRO_CODE}" \
						--path="${DISTRO_RELEASES}" --image="${IMAGE_NAME}"
exit 0

# Build image contents
echo ">> Building system packages.."
start_multithread_build system || die "Parallel build failure - see log for details. Time of failure: $(date)"

echo -e "<< Successful build, finalizing OS structure and components..\n"

# Create legacy sym links
echo ">> Creating legacy sym links.."
ln -sfn /var/media ${INSTALL}/media
ln -sfn /usr/lib ${INSTALL}/lib
ln -sfn /usr/bin ${INSTALL}/bin
ln -sfn /usr/sbin ${INSTALL}/sbin

echo "${TARGET_VERSION}" >${INSTALL}/etc/release

# Create /etc/os-release
echo ">> Creating /etc/os-release.."
cat <<EOF >${INSTALL}/etc/os-release
NAME="${DISTRO_NAME}"
VERSION="${DISTRO_VERSION} ${DISTRO_LABEL}"
ID="clue"
ID_LIKE="libreelec"
PRETTY_NAME="${DISTRO_LONGNAME} ${DISTRO_VERSION} ${DISTRO_LABEL}"
VERSION_ID="${DISTRO_VERSION}"
VERSION_CODE="${DISTRO_CODE}"
HOME_URL="https://amsd.go.ro/clue"
BUILD_ID="${GIT_HASH}"
DEVICE="${DEVICE}"
ARCH="${TARGET_ARCH}"
EOF

# Create /etc/issue
echo ">> Creating /etc/issue.."
cat <<EOF >${INSTALL}/etc/issue
Welcome to ..
              *****       **          **   **      ******
            **           **          **   **      **
           **           **          **   **      ****
          **           **          **   **      **
          *****       ******      *******      ******    OS.!

This is an open OS that comes with ABSOLUTELY NO WARRANTY!

EOF

ln -sf /etc/issue ${INSTALL}/etc/motd

# Copy system related files to filesystem
echo ">> Copying system related files to filesystem.."
if [ -d "${ROOT}/basis/filesystem" ]; then
	cp -PR ${ROOT}/basis/filesystem/* ${INSTALL}
	# Install project specific systemd services
	for service in ${ROOT}/basis/filesystem/usr/lib/systemd/system/*.service; do
		if [ -f "${service}" ]; then
			enable_service $(basename ${service})
		fi
	done
fi

# Copy DEVICE related files to filesystem
echo ">> Copying DEVICE related files to filesystem.."
if [ -n "${DEVICE}" -a -d "${ROOT}/devices/${DEVICE}/filesystem" ]; then
	cp -PR ${ROOT}/devices/${DEVICE}/filesystem/* ${INSTALL}
	# Install device specific systemd services
	for service in ${ROOT}/devices/${DEVICE}/filesystem/usr/lib/systemd/system/*.service; do
		if [ -f "${service}" ]; then
			enable_service $(basename ${service})
		fi
	done
fi

# Run depmod for base overlay modules
echo ">> Running depmod for base overlay modules.."
MODVER=$(basename $(ls -d ${INSTALL}/usr/lib/kernel-overlays/base/lib/modules/*))
find ${INSTALL}/usr/lib/kernel-overlays/base/lib/modules/${MODVER}/ -name *.ko |
	sed -e "s,${INSTALL}/usr/lib/kernel-overlays/base/lib/modules/${MODVER}/,," \
		>${INSTALL}/usr/lib/kernel-overlays/base/lib/modules/${MODVER}/modules.order
${TOOLCHAIN}/bin/depmod -b ${INSTALL}/usr/lib/kernel-overlays/base -a -e -F "${BUILDER_PACKS}/linux-$(kernel_version)/System.map" ${MODVER} 2>&1

# Strip kernel modules
echo ">> Striping kernel modules.."
for MOD in $(find ${INSTALL}/usr/lib/kernel-overlays/ -type f -name *.ko); do
	${TARGET_KERNEL_PREFIX}strip --strip-debug ${MOD}
done

# Symlink overlayed modules to /usr/lib/modules
echo ">> Symlinking overlayed modules to /usr/lib/modules.."
ln -sT /var/lib/modules ${INSTALL}/usr/lib/modules

# Symlink overlayed firmware to /usr/lib/firmware
echo ">> Symlinking overlayed firmware to /usr/lib/firmware.."
ln -sT /var/lib/firmware ${INSTALL}/usr/lib/firmware

# Make target dir
echo ">> Creating target folder.."
mkdir -p ${TARGETS}
rm -rf ${TARGETS}/${IMAGE_NAME}.kernel

# Copy kernel to target dir
echo ">> Copying kernel to target folder.."
cp -PR ${BUILDER_PACKS}/linux-$(kernel_version)/arch/${TARGET_KERNEL_ARCH}/boot/${KERNEL_TARGET} ${TARGETS}/${IMAGE_NAME}.kernel
chmod 0644 ${TARGETS}/${IMAGE_NAME}.kernel

# Set mksquashfs options for each compression method
echo ">> Setting mksquashfs options for each compression method.."
if [ -z "${SQUASHFS_COMPRESSION_OPTION}" ]; then
	if [ "${SQUASHFS_COMPRESSION:-gzip}" = "gzip" ]; then
		SQUASHFS_COMPRESSION_OPTION="-Xcompression-level 9 -b 262144"
	elif [ "${SQUASHFS_COMPRESSION}" = "lzo" ]; then
		SQUASHFS_COMPRESSION_OPTION="-Xcompression-level 9 -b 524288"
	elif [ "${SQUASHFS_COMPRESSION}" = "zstd" ]; then
		SQUASHFS_COMPRESSION_OPTION="-Xcompression-level 22 -b 262144"
	fi
fi

# Create squashfs file, default to gzip if no compression configured
echo ">> Creating squashfs file, default to gzip if no compression configured.."
echo "rm -rf \"${TARGETS}/${IMAGE_NAME}.system\"" >>${FAKEROOT_SCRIPT}
echo "${TOOLCHAIN}/bin/mksquashfs \"${BUILDER}/image/system\" \"${TARGETS}/${IMAGE_NAME}.system\" -noappend -comp ${SQUASHFS_COMPRESSION:-gzip} ${SQUASHFS_COMPRESSION_OPTION}" >>${FAKEROOT_SCRIPT}

# Run fakeroot
echo ">> Running fakeroot.."
${TOOLCHAIN}/bin/fakeroot -- ${FAKEROOT_SCRIPT}
rm -rf ${FAKEROOT_SCRIPT}

# Set permissions
echo -e ">> Setting up permissions..\n"
chmod 0644 ${TARGETS}/${IMAGE_NAME}.system

# Make release and OS image
if [ "${1}" = "release" ]; then
	echo -e "\n> Making OS release.."
	RELEASE_DIR="${TARGETS}/${IMAGE_NAME}"

	# Cleanup
	rm -rf ${RELEASE_DIR}
	# Remove any previously created release images
	rm -rf ${TARGETS}/${IMAGE_NAME}.img.gz
	# Remove any previously created release tarballs
	rm -rf ${TARGETS}/${IMAGE_NAME}.tar

	# Create release dir
	echo -e "\tCreating release and bootloader resources.."
	mkdir -p ${RELEASE_DIR}

	# Deploy bootloaded resources
	BOOTLOADER_DIR="$(get_pkg_directory "bcm2835-bootloader")"
	if [ -d ${BOOTLOADER_DIR}/files ]; then
		echo -e "\t\tDeploy bootloaded resources from ${BOOTLOADER_DIR}"
		cp -R ${BOOTLOADER_DIR}/files/* ${RELEASE_DIR}
		mkdir -p ${RELEASE_DIR}/3rdparty/bootloader
		cp -PR ${INSTALL}/usr/share/bootloader/LICENCE* ${RELEASE_DIR}/3rdparty/bootloader/
		cp -PR ${INSTALL}/usr/share/bootloader/bootcode.bin ${RELEASE_DIR}/3rdparty/bootloader/
		cp -PR ${INSTALL}/usr/share/bootloader/fixup.dat ${RELEASE_DIR}/3rdparty/bootloader/
		cp -PR ${INSTALL}/usr/share/bootloader/start.elf ${RELEASE_DIR}/3rdparty/bootloader/
		if [ -f $(get_build_dir slice-firmware)/dt-blob.bin ]; then
			cp -PR $(get_build_dir slice-firmware)/dt-blob.bin ${RELEASE_DIR}/3rdparty/bootloader/
		fi
		cp -PR ${INSTALL}/usr/share/bootloader/*.dtb ${RELEASE_DIR}/3rdparty/bootloader/
		cp -PR ${INSTALL}/usr/share/bootloader/overlays ${RELEASE_DIR}/3rdparty/bootloader/
		if [ -f ${INSTALL}/usr/share/bootloader/config.txt ]; then
			cp -PR ${INSTALL}/usr/share/bootloader/config.txt ${RELEASE_DIR}/3rdparty/bootloader/
		fi
		if [ -f ${INSTALL}/usr/share/bootloader/distroconfig.txt ]; then
			cp -PR ${INSTALL}/usr/share/bootloader/distroconfig.txt ${RELEASE_DIR}/3rdparty/bootloader/
		fi
	fi

	cp ${ROOT}/README* ${RELEASE_DIR}
	echo "${TARGET_VERSION}" >${RELEASE_DIR}/RELEASE

		echo -e "\t\tKodi commit: $(get_pkg_version kodi)" >>${RELEASE_DIR}/RELEASE

	mkdir -p ${RELEASE_DIR}/target
	cp ${TARGETS}/${IMAGE_NAME}.system ${RELEASE_DIR}/target/SYSTEM
	cp ${TARGETS}/${IMAGE_NAME}.kernel ${RELEASE_DIR}/target/KERNEL

	(	# Create md5sum's
		cd ${RELEASE_DIR}
		md5sum -t target/SYSTEM >target/SYSTEM.md5
		md5sum -t target/KERNEL >target/KERNEL.md5
	)

	# Create release tarball
	echo -e "\tCreating release tarball.."
	tar cf ${TARGETS}/${IMAGE_NAME}.tar -C ${TARGETS} ${IMAGE_NAME} || die "An error has occurred creating release tarball: $(echo '${TARGETS}/${IMAGE_NAME}.tar, over location ${TARGETS} for directory ${IMAGE_NAME}')"

	(	# Create sha256 checksum of tarball
		cd ${TARGETS}
		sha256sum ${IMAGE_NAME}.tar >${IMAGE_NAME}.tar.sha256
	)

	echo -e "\n> Making OS image.."
	UUID_SYSTEM="$(date '+%d%m')-$(date '+%M%S')"
	UUID_STORAGE="$(uuidgen)"

	# set temp variables
	LE_TMP=/tmp/.clueimg
	SAVE_ERROR="${LE_TMP}/save_error"
	rm -rf ${LE_TMP}
	mkdir -p ${LE_TMP}

	if [ -z "${SYSTEM_SIZE}" -o -z "${SYSTEM_PART_START}" ]; then
		die "SYSTEM_SIZE and SYSTEM_PART_START must be configured!"
	fi

	DISK_LABEL=msdos
	STORAGE_SIZE=32 # STORAGE_SIZE must be >= 32 !
	DISK_START_PADDING=$(((${SYSTEM_PART_START} + 2048 - 1) / 2048))
	DISK_GPT_PADDING=1
	DISK_SIZE=$((${DISK_START_PADDING} + ${SYSTEM_SIZE} + ${STORAGE_SIZE} + ${DISK_GPT_PADDING}))
	DISK_BASENAME="${TARGETS}/${IMAGE_NAME}"
	DISK="${DISK_BASENAME}.img"

	trap cleanup SIGINT

	# create an image
	echo -e "\tCreating file $(basename ${DISK})..."
	dd if=/dev/zero of="${DISK}" bs=1M count="${DISK_SIZE}" conv=fsync >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"

	# write a disklabel
	echo -e "\tCreating ${DISK_LABEL} partition table.."
	parted -s "${DISK}" mklabel ${DISK_LABEL}
	sync

	# create part1
	echo -e "\tCreating part1.."
	SYSTEM_PART_END=$((${SYSTEM_PART_START} + (${SYSTEM_SIZE} * 1024 * 1024 / 512) - 1))
	parted -s "${DISK}" -a min unit s mkpart primary fat32 ${SYSTEM_PART_START} ${SYSTEM_PART_END}
	parted -s "${DISK}" set 1 boot on
	sync

	# create part2
	echo -e "\tCreating part2.."
	STORAGE_PART_START=$((${SYSTEM_PART_END} + 1))
	STORAGE_PART_END=$((${STORAGE_PART_START} + (${STORAGE_SIZE} * 1024 * 1024 / 512) - 1))
	parted -s "${DISK}" -a min unit s mkpart primary ext4 ${STORAGE_PART_START} ${STORAGE_PART_END}
	sync

	# create filesystem on part1
	echo -e "\tCreating filesystem on part1.."
	OFFSET=$((${SYSTEM_PART_START} * 512))
	HEADS=4
	TRACKS=32
	SECTORS=$((${SYSTEM_SIZE} * 1024 * 1024 / 512 / ${HEADS} / ${TRACKS}))

	mformat -i ${DISK}@@${OFFSET} -h ${HEADS} -t ${TRACKS} -s ${SECTORS} -v "${DISTRO_BOOTLABEL}" -N "${UUID_SYSTEM//-/}" ::
	sync

	# create bootloader configuration
	echo -e "\tCreating bootloader configuration.."
	cat <<EOF >"${LE_TMP}/cmdline.txt"
boot=UUID=${UUID_SYSTEM} disk=UUID=${UUID_STORAGE} quiet ${EXTRA_CMDLINE}
EOF

	mcopy -i ${DISK}@@${OFFSET} "${LE_TMP}/cmdline.txt" ::

	# copy files
	echo -e "\tCopying files to part1.."
	mcopy -i ${DISK}@@${OFFSET} "${TARGETS}/${IMAGE_NAME}.kernel" "::/${KERNEL_NAME}"
	mcopy -i ${DISK}@@${OFFSET} "${TARGETS}/${IMAGE_NAME}.system" ::/SYSTEM
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/target/KERNEL.md5" "::/${KERNEL_NAME}.md5"
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/target/SYSTEM.md5" ::/SYSTEM.md5

	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/bootcode.bin" ::
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/fixup.dat" ::
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/start.elf" ::
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/config.txt" ::
	mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/distroconfig.txt" ::

	if [ -f "${RELEASE_DIR}/3rdparty/bootloader/dt-blob.bin" ]; then
		mcopy -i ${DISK}@@${OFFSET} "${RELEASE_DIR}/3rdparty/bootloader/dt-blob.bin" ::
	fi

	for dtb in "${RELEASE_DIR}/3rdparty/bootloader/"*.dtb; do
		if [ -f "${dtb}" ]; then
			mcopy -i ${DISK}@@${OFFSET} "${dtb}" ::/$(basename "${dtb}")
		fi
	done

	if [ -d "${RELEASE_DIR}/3rdparty/bootloader/overlays" ]; then
		mcopy -i ${DISK}@@${OFFSET} -s "${RELEASE_DIR}/3rdparty/bootloader/overlays" ::
	fi

	# extract part2 from image to format and copy files
	echo -e "\tExtracting part2 from image.."
	STORAGE_PART_COUNT=$((${STORAGE_PART_END} - ${STORAGE_PART_START} + 1))
	sync
	dd if="${DISK}" of="${LE_TMP}/part2.ext4" bs=512 skip="${STORAGE_PART_START}" count="${STORAGE_PART_COUNT}" conv=fsync >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"

	# create filesystem on part2
	echo -e "\tCreating filesystem on part2.."
	mke2fs -F -q -t ext4 -m 0 "${LE_TMP}/part2.ext4"
	tune2fs -L "${DISTRO_DISKLABEL}" -U ${UUID_STORAGE} "${LE_TMP}/part2.ext4" >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"
	e2fsck -n "${LE_TMP}/part2.ext4" >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"
	sync

	# add resize mark
	mkdir "${LE_TMP}/part2.fs"
	touch "${LE_TMP}/part2.fs/.please_resize_me"
	echo -e "\tPopulating filesystem on part2.."
	populatefs -U -d "${LE_TMP}/part2.fs" "${LE_TMP}/part2.ext4" >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"
	sync
	e2fsck -n "${LE_TMP}/part2.ext4" >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"

	# merge part2 back to disk image
	echo -e "\tMerging part2 back to image.."
	dd if="${LE_TMP}/part2.ext4" of="${DISK}" bs=512 seek="${STORAGE_PART_START}" conv=fsync,notrunc >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"

	# extract part1 from image to run fsck
	echo -e "\tExtracting part1 from image.."
	SYSTEM_PART_COUNT=$((${SYSTEM_PART_END} - ${SYSTEM_PART_START} + 1))
	sync
	dd if="${DISK}" of="${LE_TMP}/part1.fat" bs=512 skip="${SYSTEM_PART_START}" count="${SYSTEM_PART_COUNT}" conv=fsync >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"
	echo -e "\tChecking filesystem on part1.."
	fsck.fat -n "${LE_TMP}/part1.fat" >"${SAVE_ERROR}" 2>&1 || die "An error has occurred creating image: $(cat ${SAVE_ERROR})"

	# gzip
	echo -e "\tCompressing.."
	pigz --best --force "${DISK}"

	# set owner
	if [ -n "${SUDO_USER}" ]; then
		chown "${SUDO_USER}:" "${DISK}.gz"
	fi

	# create sha256 checksum of image
	cd "${TARGETS}"
	sha256sum $(basename "${DISK}").gz >$(basename "${DISK}").gz.sha256

	# cleanup
	echo -e "\tCleaning up.."
	rm -rf "${LE_TMP}"


	# Cleanup release dir
	rm -rf ${RELEASE_DIR}
fi

# process ended
echo -e "> Process ended..\n"

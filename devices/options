########################################################################################
## Project Global Variables
## Basic variables and options for distribution and media center application
##

# Name of the Distro to build (full name, without special characters)
DISTRO_NAME="Clue"

# Project long name or description
DISTRO_LONGNAME="Clue Media Experience"

# Set status, use "devel" for development version and stable for any stable version
DISTRO_STATUS="${STATUS:-devel}"

# DISTRO_VERSION: Distribution Version with minor and major revisions
DISTRO_BUILD=146
DISTRO_RELEASE=2.0
DISTRO_VERSION="${DISTRO_RELEASE}.${DISTRO_BUILD}"

# DISTRO_PROVIDER: Distribution Provider
DISTRO_PROVIDER="AMSD"

# install extra subtitle Fonts for KODI (yes / no)
KODI_EXTRA_FONTS="yes"

# build and install with BluRay support (yes / no)
KODI_BLURAY_SUPPORT="yes"

# build and install with KODI web frontend (yes / no)
KODI_WEBSERVER_SUPPORT="yes"

# build and install with DVDCSS support
# (DVD decryption support in KODI) (yes / no)
KODI_DVDCSS_SUPPORT="yes"

# build with UPnP support (yes / no)
KODI_UPNP_SUPPORT="yes"

# build with MySQL support (mysql / mariadb / none)
KODI_MYSQL_SUPPORT="mariadb"

# build xbmc with optical drive support (yes / no)
KODI_OPTICAL_SUPPORT="yes"

# build with AirPlay support (stream videos from iDevices to KODI) (yes / no)
KODI_AIRPLAY_SUPPORT="yes"

# build with AirTunes support (stream music from iDevices to KODI) (yes / no)
KODI_AIRTUNES_SUPPORT="yes"

# build with libnfs support (mounting nfs shares with KODI) (yes / no)
KODI_NFS_SUPPORT="yes"

# build with Samba Client support (mounting SAMBA shares with KODI) (yes / no)
KODI_SAMBA_SUPPORT="yes"

# LTO (Link Time Optimization) support
LTO_SUPPORT="yes"

# GOLD (Google Linker) support
GOLD_SUPPORT="yes"

# HARDENING (security relevant linker and compiler flags) support
HARDENING_SUPPORT="no"

# Root password to integrate in the target system
ROOT_PASSWORD="clue"

# Install glibc locales to the build (yes / no)
GLIBC_LOCALES="yes"

# build and install PulseAudio support (yes / no)
PULSEAUDIO_SUPPORT="yes"

# build and install espeak support (yes / no)
ESPEAK_SUPPORT="yes"

# build and install with BD+ support
# (BD+ decryption support in KODI) (yes / no)
BLURAY_BDPLUS_SUPPORT="yes"

# build and install with AACS support
# (BD decryption support in KODI) (yes / no)
BLURAY_AACS_SUPPORT="yes"

# additional drivers to install:
# for a list of additional drivers see ${PACKAGES}/abstract/drivers
# Space separated list is supported,
# e.g. ADDITIONAL_DRIVERS="DRIVER1 DRIVER2"
ADDITIONAL_DRIVERS="RTL8192CU RTL8192DU RTL8192EU RTL8188EU RTL8812AU rpi-cirrus-config bcm2835-driver"

# build and install bluetooth support (yes / no)
BLUETOOTH_SUPPORT="yes"

# build and install Avahi (Zeroconf) daemon (yes / no)
AVAHI_DAEMON="yes"

# build with NFS support (mounting nfs shares via the OS) (yes / no)
NFS_SUPPORT="yes"

# build with Samba Client support (mounting samba shares via the OS) (yes / no)
SAMBA_SUPPORT="yes"

# build and install Samba Server (yes / no)
SAMBA_SERVER="yes"

# build and install SFTP Server (yes / no)
SFTP_SERVER="yes"

# build and install OpenVPN support (yes / no)
OPENVPN_SUPPORT="yes"

# build and install WireGuard support (yes / no)
WIREGUARD_SUPPORT="yes"

# build and install diskmounter support (udevil)
# this service provide auto mounting support for external drives in the
# mediacenter also automount internally drives at boottime via udev (yes / no)
UDEVIL="yes"

# build and install exFAT fuse support (yes / no)
EXFAT="yes"

# build and install NTFS-3G fuse support (yes / no)
NTFS3G="yes"

# build and install hfs filesystem utilities (yes / no)
HFSTOOLS="yes"

# build and install CEC adapter support (yes / no)
CEC_SUPPORT="yes"

# build and install CEC framework support (yes / no)
CEC_FRAMEWORK_SUPPORT="no"

# build and install iSCSI support - iscsistart (yes / no)
ISCSI_SUPPORT="yes"

# Support for partitioning and formatting disks in initramfs (yes / no)
# This adds support for parted and mkfs.ext3/4 to initramfs for OEM usage
INITRAMFS_PARTED_SUPPORT="no"

# build with swap support (yes / no)
SWAP_SUPPORT="yes"

# swap support enabled per default (yes / no)
SWAP_ENABLED_DEFAULT="no"

# swapfile size if SWAP_SUPPORT=yes in MB
SWAPFILESIZE="128"

# build and install nano text editor (yes / no)
NANO_EDITOR="yes"

# cron support (yes / no)
CRON_SUPPORT="yes"

# Default size of system partition, in MB, eg. 512
SYSTEM_SIZE=512

# Default system partition offset, in sectors, eg. 2048
SYSTEM_PART_START=8192

# Partition labels for USB/SD installation media
DISTRO_BOOTLABEL="BOOT"
DISTRO_DISKLABEL="HOME"

# Distribution specific source locations: mirror and source repos
REPO_ADDONS="https://amsd.go.ro/clue/repos/addons"
REPO_MIRROR="https://amsd.go.ro/clue/repos/mirror"
REPO_SOURCES="https://amsd.go.ro/clue/repos/sources"
REPO_RELEASES="https://amsd.go.ro/clue/repos/releases"

# Configure debug groups (space delimited key=value pairs, with each value comma-
# delimited) and default group when DEBUG=yes
# Use ! or - prefix to prevent a dependent package from being built with debug.
# Add + suffix to build dependencies with debug.
DEBUG_GROUPS="kodi+=kodi+,kodi-platform+,p8-platform+,!mesa"
DEBUG_GROUP_YES="kodi+"

# Default supported get handlers (archive, git, file etc.)
GET_HANDLER_SUPPORT="archive"

# IR remote protocols supported in default config
IR_REMOTE_PROTOCOLS="RC6 NEC"

# IR remote keymaps supported in default config
IR_REMOTE_KEYMAPS="rc6_mce xbox_360 xbox_one"

# Kernel target
KERNEL_TARGET="zImage"

# Additional kernel make parameters
KERNEL_MAKE_EXTRACMD="dtbs"

# Kernel to use. values can be:
# default:  default mainline kernel
LINUX="raspberrypi"

# Project CFLAGS
PROJECT_CFLAGS=""

# SquashFS compression method (gzip / lzo / xz / zstd)
SQUASHFS_COMPRESSION="lzo"

# build and install ALSA Audio support (yes / no)
ALSA_SUPPORT="yes"

# OpenGL(X) implementation to use (no / mesa)
OPENGL_SUPPORT="no"
OPENGL="no"

# OpenGL-ES implementation to use (no / bcm2835-driver / mesa)
OPENGLES_SUPPORT="yes"
OPENGLES="bcm2835-driver"

# include uvesafb support (yes / no)
UVESAFB_SUPPORT="no"

# Xorg Graphic drivers to use (all / vc4 / none)
# Space separated list is supported,
# e.g. GRAPHIC_DRIVERS="vc4" (for RPi4)
GRAPHIC_DRIVERS=""

# KODI Player implementation to use (default / bcm2835-driver / mesa)
KODIPLAYER_DRIVER="bcm2835-driver"

# Modules to install in initramfs for early boot
INITRAMFS_MODULES=""

# additional Firmware to use (dvb-firmware, misc-firmware, wlan-firmware)
# Space separated list is supported,
# e.g. FIRMWARE="dvb-firmware misc-firmware wlan-firmware"
FIRMWARE="misc-firmware wlan-firmware dvb-firmware brcmfmac_sdio-firmware"

# kernel image name
KERNEL_NAME="${KERNEL:-kernel.img}"

# debug tty path
DEBUG_TTY="/dev/console"

# setup TARGET_ARCH
TARGET_ARCH="${ARCH:-arm}"

# Cache size for ccache: set the maximum size of the files stored in the cache.
# You can specify a value in gigabytes, megabytes or kilobytes by appending a G, # M or K
# to the value. The default is gigabytes. The actual value stored is rounded # down to the
# nearest multiple of 16 kilobytes.  Keep in mind this per project .ccache directory.
CCACHE_CACHE_SIZE="${CACHE_SIZE:5G}"

# debug flag (yes/no)
DEBUG="${DEBUG:-no}"

# verbose compilation mode (yes/no)
VERBOSE="${VERBOSE:-yes}"

# Build debug with valgrind (yes / no) - not available for armv6. Increases image size significantly
VALGRIND="no"

# set default language for build system
export LC_ALL=C

## Multi-thread configuration for building process
THREADCOUNT=${THREADCOUNT:-50%}

# Do not build as root
if [[ "${EUID}" -eq 0 ]]; then
	echo "Building as the root user is NOT supported. Use a regular user account for the build." 1>&2
	exit 1
fi

# Spaces in paths are verboten
if [[ ${PWD} =~ [[:space:]] ]]; then
	echo "Current PWD: \"${PWD}\"" 1>&2
	echo 1>&2
	echo "Building in a folder that includes spaces is NOT supported. Use a folder without spaces." 1>&2
	exit 1
fi

########################################################################################
## Include references (set of general functions and same options to be overwritten)
##

# Read global persistent options from $HOME if available
if [ -f "${HOME}/.clue/options" ]; then
	. "${HOME}/.clue/options"
fi

# Read DEVICE options if available
if [ -f "${ROOT}/devices/${DEVICE}/options" ]; then
	. "${ROOT}/devices/${DEVICE}/options"
fi

########################################################################################
## Build up dynamic options and project variables and run environment procedures
##

# projects can set KERNEL_NAME (kernel.img)
LINUX_DEPENDS="${ROOT}/basis/linux ${ROOT}/basis/patches/linux ${ROOT}/${PACKAGES}/linux"
[ -n "${DEVICE}" ] && LINUX_DEPENDS+=" ${ROOT}/devices/${DEVICE}/linux ${ROOT}/devices/${DEVICE}/patches/linux ${ROOT}/devices/${DEVICE}/${PACKAGES}/linux"

# Need to point to your actual cc
# If you have ccache installed, take care that LOCAL_CC does not point to it
[ -z "${LOCAL_CC}" ] && export LOCAL_CC="$(command -v gcc)"

if [ -z "${LOCAL_CC}" ]; then
	die "***** Please install gcc *****" "127"
fi

# Need to point to your actual g++
# If you have ccache installed, take care that LOCAL_CXX does not point to it
[ -z "${LOCAL_CXX}" ] && export LOCAL_CXX="$(command -v g++)"

# Concurrency make level (-j option)
#  Try values between 1 and number of processor cores present.
#  default: use all cores
[ -z "${CONCURRENCY_MAKE_LEVEL}" ] && export CONCURRENCY_MAKE_LEVEL=$(nproc)

# The TARGET_CPU variable controls which processor should be targeted for generated code.
# Valid TARGET_CPU for Raspberry Pi based devices are:
# arm1176jzf-s cortex-a7 cortex-a53
if [ "$DEVICE" = "RPi" -o "$DEVICE" = "Slice" ]; then
	TARGET_CPU="arm1176jzf-s"
elif [ "$DEVICE" = "RPi2" -o "$DEVICE" = "Slice3" ]; then
	TARGET_CPU="cortex-a7"
elif [ "$DEVICE" = "RPi4" ]; then
	TARGET_CPU="cortex-a53"
	TARGET_CPU_FLAGS="+crc"
fi

# Specifies which floating-point ABI to use. Permissible values are: soft hard
TARGET_FLOAT="hard"

# Valid TARGET_FPU for Raspberry Pi based devices:
# This specifies what floating point hardware (or hardware emulation) is
# available on the target. Permissible names are:
# vfp neon-vfpv4 neon-fp-armv8
if [ "$DEVICE" = "RPi" -o "$DEVICE" = "Slice" ]; then
	TARGET_FPU="vfp"
elif [ "$DEVICE" = "RPi2" -o "$DEVICE" = "Slice3" ]; then
	TARGET_FPU="neon-vfpv4"
elif [ "$DEVICE" = "RPi4" ]; then
	TARGET_FPU="neon-fp-armv8"
fi
TARGET_FEATURES="32bit"

# Determine architecture's family
case $TARGET_CPU in
	arm1176jzf-s)
		TARGET_SUBARCH=armv6zk
		TARGET_ABI=eabi
		TARGET_EXTRA_FLAGS="-mcpu=$TARGET_CPU"
		TARGET_FPU_FLAGS="-mfloat-abi=$TARGET_FLOAT -mfpu=$TARGET_FPU"
		;;
	cortex-a7 | cortex-a15 | cortex-a17 | cortex-a15.cortex-a7 | cortex-a17.cortex-a7)
		TARGET_SUBARCH=armv7ve
		TARGET_ABI=eabi
		TARGET_EXTRA_FLAGS="-mcpu=$TARGET_CPU"
		TARGET_FPU_FLAGS="-mfloat-abi=$TARGET_FLOAT -mfpu=$TARGET_FPU"
		TARGET_FEATURES+=" neon"
		;;
	cortex-a5 | cortex-a8 | cortex-a9)
		TARGET_SUBARCH=armv7-a
		TARGET_ABI=eabi
		TARGET_EXTRA_FLAGS="-mcpu=$TARGET_CPU"
		TARGET_FPU_FLAGS="-mfloat-abi=$TARGET_FLOAT -mfpu=$TARGET_FPU"
		TARGET_FEATURES+=" neon"
		;;
	cortex-a53 | cortex-a72.cortex-a53)
		TARGET_SUBARCH=armv8-a
		TARGET_ABI=eabi
		TARGET_EXTRA_FLAGS="-mcpu=${TARGET_CPU}"
		TARGET_FPU_FLAGS="-mfloat-abi=$TARGET_FLOAT -mfpu=$TARGET_FPU"
		TARGET_FEATURES+=" neon"
		;;
esac

TARGET_VARIANT="${TARGET_SUBARCH}${TARGET_CPU_FLAGS}"
TARGET_GCC_ARCH=${TARGET_SUBARCH/-/}
TARGET_KERNEL_ARCH=${TARGET_KERNEL_ARCH:-arm}

# setup ARCH specific *FLAGS
TARGET_CFLAGS="-march=$TARGET_VARIANT -mtune=$TARGET_CPU -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated $TARGET_EXTRA_FLAGS"
[ -n "$TARGET_FPU" ] && TARGET_CFLAGS="$TARGET_CFLAGS $TARGET_FPU_FLAGS"
TARGET_LDFLAGS="-march=$TARGET_VARIANT -mtune=$TARGET_CPU"
GCC_OPTS="--with-abi=aapcs-linux --with-arch=$TARGET_SUBARCH --with-float=$TARGET_FLOAT --with-fpu=$TARGET_FPU"

[ -z "${HOST_NAME}" ] && export HOST_NAME="$($LOCAL_CC -dumpmachine)"
TARGET_NAME=${TARGET_GCC_ARCH}-clue-linux-gnu${TARGET_ABI}

# Include additional variables and environment configurations for path
# setup initial directories (relative to root)
SOURCES=${OUTPUT_DIR}/sources
TARGETS=${OUTPUT_DIR}/targets
BUILDER=${OUTPUT_DIR}/${DISTRO_STATUS}-${DEVICE}.${TARGET_ARCH}-${DISTRO_NAME}-${DISTRO_RELEASE}

BUILDER_PACKS=${BUILDER}/${PACKAGES}
BUILDER_THREADS=${BUILDER}/.threads
BUILDER_STAMPS=${BUILDER}/.stamps
INSTALL_STAMPS=${BUILDER}/image/.stamps
TOOLCHAIN=${BUILDER}/toolchain
TARGET_SYSROOT=${TOOLCHAIN}/${TARGET_NAME}/sysroot
TARGET_PREFIX=${TOOLCHAIN}/bin/${TARGET_NAME}-

# use ARM toolchain on 64/32 split builds
if [ -z "$KERNEL_TOOLCHAIN" -a "$TARGET_KERNEL_ARCH" = "arm64" -a "$TARGET_ARCH" = "arm" ]; then
	KERNEL_TOOLCHAIN="aarch64-linux-gnu"
fi
if [ -n "$KERNEL_TOOLCHAIN" ]; then
	TARGET_KERNEL_PREFIX=$TOOLCHAIN/lib/gcc-arm-$KERNEL_TOOLCHAIN/bin/$KERNEL_TOOLCHAIN-
else
	TARGET_KERNEL_PREFIX=$TARGET_PREFIX
fi

FAKEROOT_SCRIPT=${BUILDER}/.fakeroot

if [ -z "$INSTALL" ]; then
	INSTALL=${BUILDER}/image/system
fi
INSTALL_INIT=${BUILDER}/image/initramfs/root-image

MAKE="$TOOLCHAIN/bin/make"

XORG_PATH_DRI=/usr/lib/dri
XORG_PATH_XKB=/usr/share/X11/xkb
XORG_PATH_XKB_OUTPUT=/var/lib/xkb
XORG_PATH_RGB=/usr/lib/X11/rgb
XORG_PATH_MODULES=/usr/lib/xorg/modules
XORG_PATH_DRIVERS=/usr/lib/xorg/modules/drivers

## optimize environment configuration
GCC_OPTIM="-Os"
# Linker hash-style is set to gnu via gcc default
LD_OPTIM="-Wl,--as-needed"

if [ "${BUILD_WITH_DEBUG}" = "yes" ]; then
	TARGET_CFLAGS="$TARGET_CFLAGS -ggdb"
	TARGET_CXXFLAGS="$TARGET_CXXFLAGS -ggdb"
	TARGET_LDFLAGS="$TARGET_LDFLAGS -ggdb"
else
	TARGET_CFLAGS="$TARGET_CFLAGS -fomit-frame-pointer"
	TARGET_CXXFLAGS="$TARGET_CXXFLAGS -fomit-frame-pointer"
	TARGET_LDFLAGS="$TARGET_LDFLAGS"
fi

NINJA_OPTS=""

TARGET_CPPFLAGS=""
TARGET_CFLAGS="$TARGET_CFLAGS -Wall -pipe $GCC_OPTIM $PROJECT_CFLAGS"
TARGET_CXXFLAGS="$TARGET_CFLAGS"
TARGET_LDFLAGS="$TARGET_LDFLAGS $LD_OPTIM"
TARGET_LIBDIR="$TARGET_SYSROOT/lib $TARGET_SYSROOT/usr/lib"
TARGET_INCDIR="$TARGET_SYSROOT/include $TARGET_SYSROOT/usr/include"

HOST_CPPFLAGS=""
HOST_CFLAGS="-march=native -O2 -Wall -pipe -I$TOOLCHAIN/include"
HOST_CXXFLAGS="$HOST_CFLAGS"
HOST_LDFLAGS="-Wl,-rpath,$TOOLCHAIN/lib -L$TOOLCHAIN/lib"
HOST_INCDIR="$TOOLCHAIN/include /usr/include"

# Workaround Ubuntu default C*FLAGS
HOST_CFLAGS="$HOST_CFLAGS -Wno-format-security"
HOST_CXXFLAGS="$HOST_CXXFLAGS -Wno-format-security"

# lto flags
FLAGS_OPTIM_LTO_NO_PARALLEL="-flto"
FLAGS_OPTIM_LTO_PARALLEL="-flto=${CONCURRENCY_MAKE_LEVEL}"
FLAGS_OPTIM_LTO_NO_FAT="-fno-fat-lto-objects"
FLAGS_OPTIM_LTO_FAT="-ffat-lto-objects"
FLAGS_OPTIM_LTO_OFF="-fno-lto"
LDFLAGS_OPTIM_LTO_COMMON="-fuse-linker-plugin"

# gold flags
LDFLAGS_OPTIM_GOLD="-fuse-ld=gold"

# position-independent code
CFLAGS_OPTIM_PIC="-fPIC -DPIC"
CXXFLAGS_OPTIM_PIC="-fPIC -DPIC"
LDFLAGS_OPTIM_PIC="-fPIC"

# hardening support
# TODO: basically copied from debian 9, should adjust for Clue
CFLAGS_OPTIM_HARDENING="-fstack-protector-strong -Wformat -Werror=format-security -fPIE"
CXXFLAGS_OPTIM_HARDENING="-fstack-protector-strong -Wformat -Werror=format-security -fPIE"
CPPFLAGS_OPTIM_HARDENING="-D_FORTIFY_SOURCE=2"
LDFLAGS_OPTIM_HARDENING="-Wl,-z,relro -Wl,-z,now"

# add distro specific library dirs
if [ -z "$HOST_LIBDIR" ]; then
	HOST_LIBDIR="$TOOLCHAIN/lib"

	# ubuntu/debian specific "multiarch support"
	export MACHINE_HARDWARE_NAME="$(uname -m)"
	export MACHINE_HARDWARE_PLATFORM="$(uname -i)"
	FAMILY_TRIPLET=${HOST_NAME/${MACHINE_HARDWARE_NAME}/${MACHINE_HARDWARE_PLATFORM}}
	if [ -d /lib/$FAMILY_TRIPLET ]; then
		HOST_LIBDIR="$HOST_LIBDIR /lib/$FAMILY_TRIPLET"
	fi
	if [ -d /usr/lib/$FAMILY_TRIPLET ]; then
		HOST_LIBDIR="$HOST_LIBDIR /usr/lib/$FAMILY_TRIPLET"
	fi

	# default dirs
	export HOST_LIBDIR="$HOST_LIBDIR /lib /usr/lib"
fi

## setup build environment
if [ -z "$CCACHE_DIR" ]; then
	export CCACHE_DIR=${OUTPUT_DIR}/.ccache
fi

if [[ -z "$PATH" || ("$PATH" != "$TOOLCHAIN/bin:$TOOLCHAIN/sbin" && "$PATH" == "${PATH#$TOOLCHAIN/bin:$TOOLCHAIN/sbin:}") ]]; then
	export PATH="$TOOLCHAIN/bin:$TOOLCHAIN/sbin${PATH:+":$PATH"}"
fi

########################################################################################
## Package processing (calls and routines' implementation)
##

# redirect formatted output
export BUILD_INDENT_SIZE=4
SILENT_OUT=3
VERBOSE_OUT=4

if [ "$VERBOSE" = yes ]; then
	exec 3>&1
	exec 4>&1
else
	exec 3>&2
	exec 4>/dev/null
fi

unset LD_LIBRARY_PATH

# multilib? nah
unset CONFIG_SITE

# meh suse
unset PYTHONSTARTUP
unset PYTHONPATH

# die (message, code) abort with optional message and code
die()
{
	if [ -n "$1" ]; then
		echo -e "$1" >&2
	fi
	exit "${2:-1}"
}

# return 0 if $2 in space-separated list $1, otherwise return 1
listcontains()
{
	if [ -n "$1" -a -n "$2" ]; then
		[[ ${1} =~ (^|[[:space:]])${2}($|[[:space:]]) ]] && return 0 || return 1
	else
		return 1
	fi
}

# remove item(s) from list.
# looping makes it greedy (eg. listremoveitem "abc def ghi" "(abc|def)" removes both "abc" and "def").
listremoveitem()
{
	local data="${1}" odata tmp_array
	if [ -n "$1" -a -n "$2" ]; then
		while [ : ]; do
			odata="${data}"
			data="$(echo "${data}" | sed -E "s (^|[[:space:]])${2}($|[[:space:]]) \  g")"
			[ "${odata}" = "${data}" ] && break
		done
	fi
	# Use array word splitting to squash spaces
	tmp_array=(${data})
	echo "${tmp_array[@]}"
}

print_color()
{
	local clr_name="$1" clr_text="$2" clr_actual
	local black red green yellow blue magenta cyan white endcolor
	local boldblack boldred boldgreen boldyellow boldblue boldmagenta boldcyan boldwhite

	[ -z "${clr_name}" ] && return 0

	if [ "$DISABLE_COLORS" = "yes" ]; then
		[ $# -eq 2 ] && echo -en "${clr_text}"
		return 0
	fi

	black="\e[0;30m"
	boldblack="\e[1;30m"
	red="\e[0;31m"
	boldred="\e[1;31m"
	green="\e[0;32m"
	boldgreen="\e[1;32m"
	yellow="\e[0;33m"
	boldyellow="\e[1;33m"
	blue="\e[0;34m"
	boldblue="\e[1;34m"
	magenta="\e[0;35m"
	boldmagenta="\e[1;35m"
	cyan="\e[0;36m"
	boldcyan="\e[1;36m"
	white="\e[0;37m"
	boldwhite="\e[1;37m"
	endcolor="\e[0m"

	# $clr_name can be a color variable (boldgreen etc.) or a
	# "standard" color determined by an indirect name (CLR_ERROR etc.)
	#
	# If ${!clr_name} doesn't exist then assume it's a standard color.
	# If ${!clr_name} does exist then check it's not a custom color mapping.
	# Custom color mappings can be configured in options files.
	#
	clr_actual="${!clr_name}"

	if [ -n "${clr_actual}" ]; then
		clr_actual="${!clr_actual}"
	else
		case "${clr_name}" in
			CLR_ERROR) clr_actual="${boldred}" ;;
			CLR_WARNING) clr_actual="${boldred}" ;;
			CLR_WARNING_DIM) clr_actual="${red}" ;;

			CLR_APPLY_PATCH) clr_actual="${boldgreen}" ;;
			CLR_AUTORECONF) clr_actual="${boldmagenta}" ;;
			CLR_BUILD) clr_actual="${boldyellow}" ;;
			CLR_TOOLCHAIN) clr_actual="${boldmagenta}" ;;
			CLR_CLEAN) clr_actual="${boldred}" ;;
			CLR_FIXCONFIG) clr_actual="${boldyellow}" ;;
			CLR_GET) clr_actual="${boldcyan}" ;;
			CLR_INFO) clr_actual="${boldgreen}" ;;
			CLR_INSTALL) clr_actual="${boldgreen}" ;;
			CLR_PATCH_DESC) clr_actual="${boldwhite}" ;;
			CLR_TARGET) clr_actual="${boldwhite}" ;;
			CLR_UNPACK) clr_actual="${boldcyan}" ;;

			CLR_ENDCOLOR) clr_actual="${endcolor}" ;;

			*) clr_actual="${endcolor}" ;;
		esac
	fi

	if [ $# -eq 2 ]; then
		echo -en "${clr_actual}${clr_text}${endcolor}"
	else
		echo -en "${clr_actual}"
	fi
}

# print build progress messages
# param1: message color, p2: label, p3: text, p4: indent (optional)
build_msg()
{
	local spaces

	[ -n "${BUILD_INDENT}" ] && spaces="$(printf "%${BUILD_INDENT}c" " ")" || spaces=""

	if [ -n "${3}" ]; then
		echo -e "${spaces}$(print_color "${1}" "${2}")      ${3}" >&${SILENT_OUT}
	else
		echo -e "${spaces}$(print_color "${1}" "${2}")" >&${SILENT_OUT}
	fi

	# pad left space to create "indent" effect
	if [ "${4}" = "indent" ]; then
		export BUILD_INDENT=$((${BUILD_INDENT:-0} + ${BUILD_INDENT_SIZE}))
	elif [ -n "${4}" ]; then
		die "ERROR: ${0} unexpected parameter: ${4}"
	fi
}

# prints a warning if the file slated for removal doesn't exist
# this allows us to continue instead of bailing out with just "rm"
safe_remove()
{
	local path="$1"

	[ -z "${path}" ] && return 0

	if [ -e "${path}" -o -L "${path}" ]; then
		rm -r "${path}"
	elif [ -n "${PKG_NAME}" ]; then
		print_color CLR_WARNING "safe_remove: path does not exist: [${PKG_NAME}]: ${path}\n"
	else
		print_color CLR_WARNING "safe_remove: path does not exist: ${path}\n"
	fi
}

### BUILDSYSTEM HELPERS ###
# check if a flag is enabled
# $1: flag-name, $2: default (yes/no), $3: ingenious check (none,only-disable,only-enable)
# set variable PKG_[FLAG]_[HOST/TARGET]_ENABLED=(yes/no)
# return 0 if flag is enabled, otherwise 1
flag_enabled()
{
	# make flag name upper case and replace hyphen with underscore, to use as variable name
	local flag_name=${1^^}
	[[ $flag_name =~ : ]] || flag_name+="_TARGET"
	flag_name="PKG_${flag_name//[:-]/_}_ENABLED"

	# check flag
	if [ -n "${PKG_BUILD_FLAGS}" ] && listcontains "${PKG_BUILD_FLAGS}" "[+]?$1"; then
		if [ "${3:none}" = "only-disable" ]; then
			die "ERROR: $1 cannot enable via PKG_BUILD_FLAGS (found in $PKG_NAME)"
		fi
		declare ${flag_name}="yes"
		return 0
	elif [ "$2" = "yes" ] && ! listcontains "${PKG_BUILD_FLAGS}" "-$1"; then
		declare ${flag_name}="yes"
		return 0
	else
		if [ "${3:none}" = "only-enable" ]; then
			die "ERROR: $1 cannot disable via PKG_BUILD_FLAGS (found in $PKG_NAME)"
		fi
		declare ${flag_name}="no"
		return 1
	fi
}

setup_pkg_config_target()
{
	export PKG_CONFIG="$TOOLCHAIN/bin/pkg-config"
	export PKG_CONFIG_PATH=""
	export PKG_CONFIG_LIBDIR="$TARGET_SYSROOT/usr/lib/pkgconfig:$TARGET_SYSROOT/usr/share/pkgconfig"
	export PKG_CONFIG_SYSROOT_DIR="$TARGET_SYSROOT"
	export PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1
	export PKG_CONFIG_ALLOW_SYSTEM_LIBS=1
}

setup_pkg_config_host()
{
	export PKG_CONFIG="$TOOLCHAIN/bin/pkg-config"
	export PKG_CONFIG_PATH=""
	export PKG_CONFIG_LIBDIR="$TOOLCHAIN/lib/pkgconfig:$TOOLCHAIN/share/pkgconfig"
	export PKG_CONFIG_SYSROOT_DIR=""
	unset PKG_CONFIG_ALLOW_SYSTEM_CFLAGS
	unset PKG_CONFIG_ALLOW_SYSTEM_LIBS
}

setup_toolchain()
{
	if [ "$LTO_SUPPORT" = "yes" ]; then
		if flag_enabled "lto-parallel" "no"; then
			TARGET_CFLAGS+=" $FLAGS_OPTIM_LTO_PARALLEL $FLAGS_OPTIM_LTO_NO_FAT"
			TARGET_CXXFLAGS+=" $FLAGS_OPTIM_LTO_PARALLEL $FLAGS_OPTIM_LTO_NO_FAT"
			TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_LTO_COMMON $FLAGS_OPTIM_LTO_PARALLEL"
		elif flag_enabled "lto-fat" "no"; then
			TARGET_CFLAGS+=" $FLAGS_OPTIM_LTO_NO_PARALLEL $FLAGS_OPTIM_LTO_FAT"
			TARGET_CXXFLAGS+=" $FLAGS_OPTIM_LTO_NO_PARALLEL $FLAGS_OPTIM_LTO_FAT"
			TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_LTO_COMMON $FLAGS_OPTIM_LTO_NO_PARALLEL"
		elif flag_enabled "lto" "no"; then
			TARGET_CFLAGS+=" $FLAGS_OPTIM_LTO_NO_PARALLEL $FLAGS_OPTIM_LTO_NO_FAT"
			TARGET_CXXFLAGS+=" $FLAGS_OPTIM_LTO_NO_PARALLEL $FLAGS_OPTIM_LTO_NO_FAT"
			TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_LTO_COMMON $FLAGS_OPTIM_LTO_NO_PARALLEL"
		fi
	fi

	if flag_enabled "lto-off" "no"; then
		TARGET_CFLAGS+=" $FLAGS_OPTIM_LTO_OFF"
		TARGET_CXXFLAGS+=" $FLAGS_OPTIM_LTO_OFF"
		TARGET_LDFLAGS+=" $FLAGS_OPTIM_LTO_OFF"
	fi

	# gold flag
	if flag_enabled "gold" "$GOLD_SUPPORT" "only-disable"; then
		TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_GOLD"
	fi

	# position-independent code
	if flag_enabled "pic" "no"; then
		TARGET_CFLAGS+=" $CFLAGS_OPTIM_PIC"
		TARGET_CXXFLAGS+=" $CXXFLAGS_OPTIM_PIC"
		TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_PIC"
	fi
	if flag_enabled "pic:host" "no"; then
		HOST_CFLAGS+=" $CFLAGS_OPTIM_PIC"
		HOST_CXXFLAGS+=" $CXXFLAGS_OPTIM_PIC"
		HOST_LDFLAGS+=" $LDFLAGS_OPTIM_PIC"
	fi

	# hardening support
	if flag_enabled "hardening" "$HARDENING_SUPPORT"; then
		TARGET_CFLAGS+=" $CFLAGS_OPTIM_HARDENING"
		TARGET_CXXFLAGS+=" $CXXFLAGS_OPTIM_HARDENING"
		TARGET_CFLAGS+=" $CPPFLAGS_OPTIM_HARDENING"
		TARGET_LDFLAGS+=" $LDFLAGS_OPTIM_HARDENING"
	fi

	# parallel
	if flag_enabled "parallel" "yes"; then
		NINJA_OPTS="$NINJA_OPTS -j$CONCURRENCY_MAKE_LEVEL"
		export MAKEFLAGS="-j$CONCURRENCY_MAKE_LEVEL"
	else
		NINJA_OPTS="$NINJA_OPTS -j1"
		export MAKEFLAGS="-j1"
	fi

	# verbose flag
	if flag_enabled "verbose" "no"; then
		NINJA_OPTS="$NINJA_OPTS -v"
		export MAKEFLAGS="$MAKEFLAGS V=1 VERBOSE=1"
	fi

	case "$1" in
		target | init)
			export DESTIMAGE="target"
			export CC="${TARGET_PREFIX}gcc"
			export CXX="${TARGET_PREFIX}g++"
			export CPP="${TARGET_PREFIX}cpp"
			export LD="${TARGET_PREFIX}ld"
			export AS="${TARGET_PREFIX}as"
			export AR="${TARGET_PREFIX}ar"
			export NM="${TARGET_PREFIX}nm"
			export RANLIB="${TARGET_PREFIX}ranlib"
			export OBJCOPY="${TARGET_PREFIX}objcopy"
			export OBJDUMP="${TARGET_PREFIX}objdump"
			export STRIP="${TARGET_PREFIX}strip"
			export CPPFLAGS="$TARGET_CPPFLAGS"
			export CFLAGS="$TARGET_CFLAGS"
			export CXXFLAGS="$TARGET_CXXFLAGS"
			export LDFLAGS="$TARGET_LDFLAGS"
			setup_pkg_config_target
			export CMAKE_CONF=$TOOLCHAIN/etc/cmake-$TARGET_NAME.conf
			export CMAKE="cmake -DCMAKE_TOOLCHAIN_FILE=$CMAKE_CONF -DCMAKE_INSTALL_PREFIX=/usr"
			if [ ! -f $CMAKE_CONF ]; then
				mkdir -p $TOOLCHAIN/etc
				echo "SET(CMAKE_SYSTEM_NAME Linux)" >>$CMAKE_CONF
				echo "SET(CMAKE_SYSTEM_VERSION 1)" >>$CMAKE_CONF
				echo "SET(CMAKE_SYSTEM_PROCESSOR  $TARGET_ARCH)" >>$CMAKE_CONF
				echo "SET(CMAKE_C_COMPILER   $CC)" >>$CMAKE_CONF
				echo "SET(CMAKE_CXX_COMPILER $CXX)" >>$CMAKE_CONF
				echo "SET(CMAKE_CPP_COMPILER $CPP)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH  $TARGET_SYSROOT)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)" >>$CMAKE_CONF
			fi
			export HOST_CC="$TOOLCHAIN/bin/host-gcc"
			export HOST_CXX="$TOOLCHAIN/bin/host-g++"
			export HOSTCC="$HOST_CC"
			export HOSTCXX="$HOST_CXX"
			export CC_FOR_BUILD="$HOST_CC"
			export CXX_FOR_BUILD="$HOST_CXX"
			export BUILD_CC="$HOST_CC"
			export BUILD_CXX="$HOST_CXX"
			export _python_sysroot="$TARGET_SYSROOT"
			export _python_prefix=/usr
			export _python_exec_prefix=/usr
			;;
		host | bootstrap)
			export DESTIMAGE="host"
			export AWK="gawk"
			export CC="$TOOLCHAIN/bin/host-gcc"
			export CXX="$TOOLCHAIN/bin/host-g++"
			export CPP="cpp"
			export LD="ld"
			export AS="as"
			export AR="ar"
			export NM="nm"
			export RANLIB="ranlib"
			export OBJCOPY="objcopy"
			export OBJDUMP="objdump"
			export STRIP="strip"
			export CPPFLAGS="$HOST_CPPFLAGS"
			export CFLAGS="$HOST_CFLAGS"
			export CXXFLAGS="$HOST_CXXFLAGS"
			export LDFLAGS="$HOST_LDFLAGS"
			setup_pkg_config_host
			export CMAKE_CONF=$TOOLCHAIN/etc/cmake-$HOST_NAME.conf
			export CMAKE="cmake -DCMAKE_TOOLCHAIN_FILE=$CMAKE_CONF -DCMAKE_INSTALL_PREFIX=$TOOLCHAIN"
			if [ ! -f $CMAKE_CONF ]; then
				mkdir -p $TOOLCHAIN/etc
				echo "SET(CMAKE_SYSTEM_NAME Linux)" >>$CMAKE_CONF
				echo "SET(CMAKE_SYSTEM_VERSION 1)" >>$CMAKE_CONF
				echo "SET(CMAKE_SYSTEM_PROCESSOR ${MACHINE_HARDWARE_NAME})" >>$CMAKE_CONF
				echo "SET(CMAKE_C_COMPILER   $CC)" >>$CMAKE_CONF
				echo "SET(CMAKE_CXX_COMPILER $CXX)" >>$CMAKE_CONF
				echo "SET(CMAKE_CPP_COMPILER $CXX)" >>$CMAKE_CONF
				echo "SET(CMAKE_AR $AR CACHE FILEPATH "Archiver")" >>$CMAKE_CONF # hum?
				echo "SET(CMAKE_FIND_ROOT_PATH  $TOOLCHAIN)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM BOTH)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY BOTH)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE BOTH)" >>$CMAKE_CONF
				echo "SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)" >>$CMAKE_CONF
			fi
			export HOST_CC="$CC"
			export HOST_CXX="$CXX"
			export HOSTCC="$CC"
			export HOSTCXX="$CXX"
			export CC_FOR_BUILD="$CC"
			export CXX_FOR_BUILD="$CXX"
			export BUILD_CC="$CC"
			export BUILD_CXX="$CXX"
			export _python_sysroot="$TOOLCHAIN"
			export _python_prefix=/
			export _python_exec_prefix=/
			;;
	esac
}

create_meson_conf()
{
	local endian root properties
	case "$1" in
		target | init)
			root="$TARGET_SYSROOT/usr"
			;;
		host | bootstrap)
			root="$TOOLCHAIN"
			;;
	esac

	properties="PKG_MESON_PROPERTIES_${1^^}"

	cat >$2 <<EOF
[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
pkgconfig = '$PKG_CONFIG'
llvm-config = '$TARGET_SYSROOT/usr/bin/llvm-config-host'

[host_machine]
system = 'linux'
cpu_family = '$TARGET_ARCH'
cpu = '$TARGET_SUBARCH'
endian = 'little'

[properties]
root = '$root'
$(python -c "import os; print('c_args = {}'.format([x for x in os.getenv('CFLAGS').split()]))")
$(python -c "import os; print('c_link_args = {}'.format([x for x in os.getenv('LDFLAGS').split()]))")
$(python -c "import os; print('cpp_args = {}'.format([x for x in os.getenv('CXXFLAGS').split()]))")
$(python -c "import os; print('cpp_link_args = {}'.format([x for x in os.getenv('LDFLAGS').split()]))")
${!properties}
EOF
}

# unset all PKG_* vars apart from those exported by setup_toolchain, then set default values
reset_pkg_vars()
{
	local vars var

	for var in ${!PKG_*}; do
		if [ "${var}" = "PKG_CONFIG" ] ||
			[ "${var}" = "PKG_CONFIG_PATH" ] ||
			[ "${var}" = "PKG_CONFIG_LIBDIR" ] ||
			[ "${var}" = "PKG_CONFIG_SYSROOT_DIR" ] ||
			[ "${var}" = "PKG_CONFIG_ALLOW_SYSTEM_CFLAGS" ] ||
			[ "${var}" = "PKG_CONFIG_ALLOW_SYSTEM_LIBS" ]; then
			continue
		fi
		vars+="${var} "
	done
	[ -n "${vars}" ] && unset -v ${vars}

	PKG_VERSION="0.0invalid"
	PKG_ARCH="any"
	PKG_TOOLCHAIN="auto"
	PKG_PYTHON_VERSION="python2.7"
}

set_debug_depends()
{
	local pkg dep_pkg map tmp_array mpkg bpkg kvpair

	_DEBUG_DEPENDS_LIST=""
	_DEBUG_PACKAGE_LIST=""
	if [ "${DEBUG:-no}" != "no" ]; then
		# Convert DEBUG_GROUPS into array of groups, adding "all" if required
		declare -A debug_group_map
		for kvpair in ${DEBUG_GROUPS}; do
			debug_group_map+=(["${kvpair%=*}"]="${kvpair#*=}")
		done
		[ -z "${debug_group_map["all"]}" ] && debug_group_map+=(["all"]="all")

		# Expand $DEBUG into $_DEBUG_PACKAGE_LIST
		for pkg in ${DEBUG//,/ }; do
			[ "${pkg}" = "yes" ] && pkg="${DEBUG_GROUP_YES:-all}"
			map="${debug_group_map["${pkg}"]}"
			[ -z "${map}" ] && map="${pkg}"
			for mpkg in ${map//,/ }; do
				[[ ${mpkg} =~ ^[!-] ]] && bpkg="${mpkg:1}" || bpkg="${mpkg}"
				[[ ${bpkg} =~ \+$ ]] && bpkg="${bpkg::-1}"
				# Remove existing instances of this package
				listcontains "${_DEBUG_PACKAGE_LIST}" "[!-]?${bpkg}[+]?" && _DEBUG_PACKAGE_LIST="$(listremoveitem "${_DEBUG_PACKAGE_LIST}" "[!-]?${bpkg}[+]?")"
				# Add package
				_DEBUG_PACKAGE_LIST+=" ${mpkg}"
			done
		done
		# Use array word splitting to squash spaces
		tmp_array=(${_DEBUG_PACKAGE_LIST})
		_DEBUG_PACKAGE_LIST="${tmp_array[@]}"

		# Determine dependencies for each package+
		for pkg in ${_DEBUG_PACKAGE_LIST}; do
			if [ "${pkg}" != "all" ] && [[ ! ${pkg} =~ ^[!-] ]]; then
				! listcontains "${_DEBUG_DEPENDS_LIST}" "${pkg}" && _DEBUG_DEPENDS_LIST+=" ${pkg}"
				[[ ! ${pkg} =~ \+$ ]] && continue
				for dep_pkg in $(get_pkg_variable ${pkg::-1} PKG_DEPENDS_TARGET); do
					[ "${dep_pkg}" = "toolchain" ] && continue
					[[ ${dep_pkg} =~ ^.*:host$ ]] && continue
					! listcontains "${_DEBUG_DEPENDS_LIST}" "${dep_pkg}" && _DEBUG_DEPENDS_LIST+=" ${dep_pkg}"
				done
			fi
		done
		tmp_array=(${_DEBUG_DEPENDS_LIST})
		_DEBUG_DEPENDS_LIST="${tmp_array[@]}"
	fi
	export _DEBUG_DEPENDS_LIST _DEBUG_PACKAGE_LIST
}

# Return 0 if building with debug is enabled for the current package (or all packages).
# Examples: DEBUG=yes  DEBUG=all  DEBUG='all,!linux'  DEBUG=kodi  DEBUG=kodi,samba
build_with_debug()
{
	if [ "${DEBUG:-no}" != "no" -a -n "${PKG_NAME}" -a -n "${_DEBUG_DEPENDS_LIST+x}" ]; then
		# Return 1 if this package is not to be built with debug
		listcontains "${_DEBUG_PACKAGE_LIST}" "[!-]${PKG_NAME}[+]?" && return 1

		# Build all packages with debug
		listcontains "${_DEBUG_PACKAGE_LIST}" "all" && return 0

		# Debugging is enabled for at least one package, so enable debug in the "debug" abstract package
		[ "${PKG_NAME}" = "debug" ] && return 0

		# Build kernel packages with debug if we're building the kernel with debug and with dependencies
		[ "${PKG_IS_KERNEL_PKG}" = "yes" ] && listcontains "${_DEBUG_DEPENDS_LIST}" "linux\+" && return 0

		# Build this package with debug if it's a resolved dependency
		listcontains "${_DEBUG_DEPENDS_LIST}" "${PKG_NAME}" && return 0
	fi

	return 1
}

# strip
debug_strip()
{
	if [ -z "${BUILD_WITH_DEBUG}" ]; then
		die "ERROR: debug_strip() must not be called without configuring BUILD_WITH_DEBUG"
	fi

	if [ "${BUILD_WITH_DEBUG}" != "yes" ] && flag_enabled "strip" "yes"; then
		find $* -type f -executable | xargs $STRIP 2>/dev/null || :
	fi
}


init_package_cache()
{
	local _ANCHOR="@?+?@"
	local temp_global temp_local

	# If the package caches are unset, then populate them
	if [ -z "${_CACHE_PACKAGE_LOCAL}" -o -z "${_CACHE_PACKAGE_GLOBAL}" ]; then
		temp_global="$(mktemp)"
		temp_local="$(mktemp)"

		# cache device folder for packages
		if [ -n "${DEVICE}" ]; then
			find "${ROOT}/devices/${DEVICE}/${PACKAGES}" -type f -name package.csh 2>/dev/null | sed "s#/package\.csh\$#${_ANCHOR}#" >>"${temp_local}"
		fi

		# cache packages folder
		find "${ROOT}/${PACKAGES}" -type f -name package.csh 2>/dev/null | sed "s#/package\.csh\$#${_ANCHOR}#" >>"${temp_global}"

		_CACHE_PACKAGE_LOCAL="${BUILDER}/.cache_package_local"
		_CACHE_PACKAGE_GLOBAL="${BUILDER}/.cache_package_global"
		export _CACHE_PACKAGE_LOCAL _CACHE_PACKAGE_GLOBAL

		# overwrite existing cache files only when they are invalid, or not yet created
		mkdir -p "$(dirname "${_CACHE_PACKAGE_GLOBAL}")"
		if [ -f "${_CACHE_PACKAGE_LOCAL}" ] && cmp -s "${temp_local}" "${_CACHE_PACKAGE_LOCAL}"; then
			rm "${temp_local}"
		else
			mv "${temp_local}" "${_CACHE_PACKAGE_LOCAL}"
		fi
		if [ -f "${_CACHE_PACKAGE_GLOBAL}" ] && cmp -s "${temp_global}" "${_CACHE_PACKAGE_GLOBAL}"; then
			rm "${temp_global}"
		else
			mv "${temp_global}" "${_CACHE_PACKAGE_GLOBAL}"
		fi
	fi

	if [ -z "${_DEBUG_DEPENDS_LIST+x}" ]; then
		set_debug_depends
	fi
}


set_vars()
{
	rm -rf /tmp/.cluevars
	set_var "distroname" "${DISTRO_NAME}"
	set_var "distrodescription" "${DISTRO_LONGNAME}"
	set_var "distroprovider" "${DISTRO_PROVIDER}"
	set_var "distrostatus" "${DISTRO_STATUS}"
	set_var "distrobuild" "${DISTRO_BUILD}"
	set_var "distrorelease" "${DISTRO_RELEASE}"
	set_var "distroversion" "${DISTRO_VERSION}"
	set_var "repoaddons" "${REPO_ADDONS}"
	set_var "repomirror" "${REPO_MIRROR}"
	set_var "reposources" "${REPO_SOURCES}"
	set_var "reporeleases" "${REPO_RELEASES}"
	set_var "localsources" "${SOURCES}"
	set_var "localtargets" "${TARGETS}"
}


set_var()
{
	local NAME="$1"
	local VALUE="$2"

	if [ ! -f /tmp/.cluevars ]; then
		echo "${NAME}=${VALUE}" | tee /tmp/.cluevars >/dev/null
	else
		sed -i "/^${NAME}/d" /tmp/.cluevars
		sed -i "$ a ${NAME}=${VALUE}" /tmp/.cluevars
	fi
}


set_build()
{
	local NEWBUILD="0"
	local CURBUILD=$(more ${ROOT}/devices/options | grep -i "^DISTRO_BUILD=" | cut -f2 -d"=")
	CURBUILD=$(echo "${CURBUILD}" | sed -e 's/^[ \t]*//')
	NEWBUILD=$(python -c "print int($CURBUILD) + 1")
	sed -i "s|^DISTRO_BUILD=${CURBUILD}|DISTRO_BUILD=${NEWBUILD}|g" ${ROOT}/devices/options
	. ${ROOT}/devices/options ""
}


check_config()
{
	local err_msg
	local dashes=$(printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' =)

	# check device
	if [ \( -z "${DEVICE}" -a -d "${ROOT}/devices" \) -o \
		\( -n "${DEVICE}" -a ! -d "${ROOT}/devices/${DEVICE}" \) ]; then
		err_msg="\n$dashes"
		err_msg="${err_msg}\nERROR: You need to specify a valid device"
		err_msg="${err_msg}\n$dashes"
		err_msg="${err_msg}\n\nValid devices for the system:"
		for device in ${ROOT}/devices/*; do
			err_msg="${err_msg}\n - ${device##*/}"
		done
		die "${err_msg}"
	fi

	# check architecture
	if [ ! ${ROOT}/devices/${DEVICE}/linux/linux.${TARGET_ARCH}.conf ]; then
		err_msg="\n$dashes"
		err_msg="${err_msg}\nERROR: Architecture not found, use a valid architecture for your project or create a new config"
		err_msg="${err_msg}\n$dashes"
		err_msg="${err_msg}\n\nValid architectures for your system"
		for arch in ${ROOT}/devices/${DEVICE}/linux/*.conf; do
			err_msg="${err_msg}\n - $(basename $arch | cut -f2 -d'.')"
		done
		die "${err_msg}"
	fi
}


do_autoreconf()
{
	export ACLOCAL_DIR=$TARGET_SYSROOT/usr/share/aclocal

	if [ -e "$TOOLCHAIN/bin/autoconf" ]; then
		export AUTOCONF=$TOOLCHAIN/bin/autoconf
	fi

	if [ -e "$TOOLCHAIN/bin/automake" ]; then
		export AUTOMAKE=$TOOLCHAIN/bin/automake
	fi

	if [ -e "$TOOLCHAIN/bin/autopoint" ]; then
		export AUTOPOINT=$TOOLCHAIN/bin/autopoint
	fi

	if [ -e "$TOOLCHAIN/bin/libtoolize" ]; then
		export LIBTOOLIZE=$TOOLCHAIN/bin/libtoolize
	fi

	if [ -e "$TOOLCHAIN/bin/intltoolize" ]; then
		export INTLTOOLIZE=$TOOLCHAIN/bin/intltoolize
	fi

	if [ -e "$TOOLCHAIN/bin/aclocal" ]; then
		export ACLOCAL="$TOOLCHAIN/bin/aclocal -I $ACLOCAL_DIR"
	fi

	if [ -e "$TOOLCHAIN/bin/autoheader" ]; then
		export AUTOHEADER=$TOOLCHAIN/bin/autoheader
	fi

	if [ -e "$TOOLCHAIN/bin/libtool" ]; then
		export LIBTOOL=$TOOLCHAIN/bin/libtool
	fi

	if [ -e "$TOOLCHAIN/bin/autoreconf" -a -e "$INTLTOOLIZE" ]; then
		mkdir -p $ACLOCAL_DIR
		if [ -e "$LIBTOOLIZE" ]; then
			export AUTORECONF="$TOOLCHAIN/bin/autoreconf --verbose --force --install -I $ACLOCAL_DIR"
		else
			export AUTORECONF="$TOOLCHAIN/bin/autoreconf --verbose --force -I $ACLOCAL_DIR"
		fi
		$AUTORECONF $@
	fi
}

### PACKAGE HELPERS ###
# get variable ($2) for package ($1).
# avoid infinite recursion if required package is already loaded.
get_pkg_variable()
{
	if [ -n "$1" -a -n "$2" ]; then
		if [ "$1" != "$PKG_NAME" ]; then
			source_package "${1}"
		fi
		echo "${!2}"
	fi
}

# get package's build dir
get_build_dir()
{
	local _PKG_NAME="${1%:*}" _PKG_VERSION="$(get_pkg_version "$1")"
	if [ -n "$_PKG_NAME" -a -n "$_PKG_VERSION" ]; then
		echo ${BUILDER_PACKS}/${_PKG_NAME}-${_PKG_VERSION}
	fi
}

get_pkg_version()
{
	get_pkg_variable "$1" PKG_VERSION
}

get_pkg_directory()
{
	local _PKG_ROOT_NAME=${1%:*} _ALL_DIRS _FOUND=0 _ANCHOR="@?+?@" _PKG_DIR _DIR

	# Check for any available local package in preference to a global package
	for _DIR in $(grep -F "/${_PKG_ROOT_NAME}${_ANCHOR}" "${_CACHE_PACKAGE_LOCAL}"); do
		_DIR="${_DIR%${_ANCHOR}}"
		# found first, set $_PKG_DIR
		_PKG_DIR="$_DIR"
		# keep track of dirs with package.csh for detecting multiple folders
		_ALL_DIRS+="${_DIR}\n"
		_FOUND=$((_FOUND + 1))
	done

	# If there's no local package available, use the global package
	if [ $_FOUND -eq 0 ]; then
		for _DIR in $(grep -F "/${_PKG_ROOT_NAME}${_ANCHOR}" "${_CACHE_PACKAGE_GLOBAL}"); do
			_DIR="${_DIR%${_ANCHOR}}"
			# found first, set $_PKG_DIR
			_PKG_DIR="$_DIR"
			# keep track of dirs with package.csh for detecting multiple folders
			_ALL_DIRS+="${_DIR}\n"
			_FOUND=$((_FOUND + 1))
		done
	fi

	# _FOUND multiple packages? fail
	if [ $_FOUND -gt 1 ]; then
		echo "Error - multiple package folders for package ${_PKG_ROOT_NAME}:" >&2
		echo -e "$_ALL_DIRS" >&2
		die
	fi

	echo "$_PKG_DIR"
}

calculate_stamp()
{
	local stamp data

	stamp="$PKG_DIR ${ROOT}/basis/patches/$PKG_NAME"
	[ -n "$DEVICE" ] && stamp+=" ${ROOT}/devices/$DEVICE/patches/$PKG_NAME"
	[ -n "$PKG_NEED_UNPACK" ] && stamp+=" $PKG_NEED_UNPACK"

	data="$(find ${stamp} -exec sha256sum {} \; 2>/dev/null | sed "s/ ${ROOT//\//\\/}\// /")"
	[ -n "${PKG_STAMP}" ] && data+=$'\n'"$(echo "${PKG_STAMP}" | sha256sum)"

	echo "${data}" | sort | sha256sum | cut -d" " -f1
}

target_has_feature()
{
	listcontains "$TARGET_FEATURES" "$1"
}

# find path for matching file or directory, searching standard directory hierarchy, using optional default
# if a path is located it will be set in FOUND_PATH and exit code will be 0.
find_path()
{
	local test_func="$1" search="$2" default="$3"
	local dir match wildcard=0 ftype

	# support wildcard matches
	[[ $search =~ \* || $search =~ \? ]] && wildcard=1

	[ "$test_func" = "-f" ] && ftype="file" || ftype="dir"

	for dir in ${ROOT}/devices/$DEVICE/${PACKAGES}/${PKG_NAME} \
		${ROOT}/devices/$DEVICE \
		${ROOT}/resources \
		${ROOT}/basis \
		${PKG_DIR}; do
		# ignore directories with missing DEVICE or PKG_NAME components
		[[ $dir =~ /${PACKAGES}/$ ]] && continue
		[[ $dir =~ /devices/$ ]] && continue
		[[ $dir =~ /devices/${PACKAGES}/$ ]] && continue

		if [ $wildcard -eq 1 ]; then
			ls $dir/$search 1>/dev/null 2>&1 && match="$dir/$search" && break
		else
			[ $test_func "$dir/$search" ] && match="$dir/$search" && break
		fi
	done

	if [ -z "$match" -a -n "$default" ]; then
		if [[ $default =~ \* || $default =~ \? ]]; then
			ls $default 1>/dev/null 2>&1 && match="$default"
		else
			[ $test_func "$default" ] && match="$default"
		fi
	fi

	if [ -n "$match" ]; then
		FOUND_PATH="$match"
		[ "${VERBOSE_FIND_PATH,,}" = "yes" ] && echo "find_path: Searching for $ftype: \"$search\", found: \"$FOUND_PATH\"" >&2
		return 0
	else
		unset FOUND_PATH
		[ "${VERBOSE_FIND_PATH,,}" = "yes" ] && echo "find_path: Searching for $ftype: \"$search\" - not found" >&2
		return 1
	fi
}

find_file_path()
{
	find_path -f "$1" "$2"
}

find_dir_path()
{
	find_path -d "$1" "$2"
}

# p1: name of function to test for
# return 0 if function exists, 1 if not
pkg_call_exists()
{
	[ "$(type -t ${1})" = "function" ] && return 0 || return 1
}

# p1: name of function to execute unconditionally
# testing the exit code value of this function is likely to break set -e fail-on-error behaviour
pkg_call() {
	[ -n "${PKG_NAME}" ] || die "$(print_color CLR_ERROR "FAILURE: Cannot call ${1} package function when package is not known!")"

	${1}
}

unset_functions()
{
	local target

	unset -f configure_package

	unset -f pre_unpack unpack post_unpack
	unset -f pre_patch post_patch

	for target in target host init bootstrap; do
		unset -f pre_build_${target}
		unset -f pre_configure_${target} configure_${target} post_configure_${target}
		unset -f pre_make_${target} make_${target} post_make_${target}
		unset -f pre_makeinstall_${target} makeinstall_${target} post_makeinstall_${target}
	done

	unset -f pre_install post_install

	unset -f addon
}

# p1: name of package to be sourced
source_package()
{
	local opwd="${PWD}"

	# Don't use BUILD_WITH_DEBUG in "global" package.csh - instead, call the function
	# build_with_debug() directly as the function depends on various package.csh
	# variables that will be in the process of being configured. Once package.csh is
	# fully sourced we can set this variable and use it in situations where we know the
	# package has already been sourced.
	unset BUILD_WITH_DEBUG

	reset_pkg_vars
	unset_functions

	if [ -n "${1}" ]; then
		[ -f "${1}" ] && PKG_DIR="$(dirname "${1}")" || PKG_DIR="$(get_pkg_directory "${1}")"

		[ -n "$PKG_DIR" -a -r $PKG_DIR/package.csh ] || die "FAILURE: unable to source package - ${1}/package.csh does not exist"

		cd "${ROOT}"
		. ${PKG_DIR}/package.csh || die "FAILURE: an error occurred while sourcing ${PKG_DIR}/package.csh"
		cd "${opwd}"

		PKG_DESCRIPTION="${PKG_DESCRIPTION:-${PKG_NAME} (autogenerated)}"

		if [ -n "${PKG_DEPENDS_UNPACK}" ]; then
			for _p in ${PKG_DEPENDS_UNPACK}; do
				PKG_NEED_UNPACK+=" $(get_pkg_directory ${_p})"
			done
		fi

		# Automatically set PKG_SOURCE_NAME unless it is already defined.
		# PKG_SOURCE_NAME will be automatically set to a name based on
		# the $PKG_NAME-$PKG_VERSION convention.
		#
		# Any $PKG_URL that references more than a single url will abort
		# the build as these are no longer supported - use mkpkg instead.
		if [ -n "$PKG_URL" -a -z "$PKG_SOURCE_NAME" ]; then
			if [[ $PKG_URL =~ .*\ .* ]]; then
				echo "Error - packages with multiple urls are no longer supported, use mkpkg."
				echo "$PKG_URL"
				die
			fi
			if [[ ${PKG_URL} =~ .git$ || ${PKG_URL} =~ ^git:// ]]; then
				PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}
			elif [[ ${PKG_URL} =~ ^file:// ]]; then
				PKG_SOURCE_NAME=${PKG_URL#file://}
				# if no specific PKG_TAR_COPY_OPTS then default to excluding .git and .svn as they can be huge
				[ -z "${PKG_TAR_COPY_OPTS+x}" ] && PKG_TAR_COPY_OPTS="--exclude=.git --exclude=.svn"
			else
				PKG_SOURCE_NAME="${PKG_URL##*/}"
				case $PKG_SOURCE_NAME in
					${PKG_NAME}-${PKG_VERSION}.*)
						PKG_SOURCE_NAME=$PKG_SOURCE_NAME
						;;
					*.tar | *.tbz | *.tgz | *.txz | *.7z | *.zip)
						PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.${PKG_SOURCE_NAME##*\.}
						;;
					*.tar.bz2 | *.tar.gz | *.tar.xz)
						PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.tar.${PKG_SOURCE_NAME##*\.}
						;;
					*.diff | *.patch | *.diff.bz2 | *.patch.bz2 | patch-*.bz2 | *.diff.gz | *.patch.gz | patch-*.gz)
						PKG_SOURCE_NAME=$PKG_SOURCE_NAME
						;;
					*)
						PKG_SOURCE_NAME=${PKG_NAME}-${PKG_VERSION}.${PKG_SOURCE_NAME##*\.}
						;;
				esac
			fi
		fi

		PKG_BUILD="${BUILDER_PACKS}/${PKG_NAME}-${PKG_VERSION}"
	fi

	build_with_debug && BUILD_WITH_DEBUG="yes" || BUILD_WITH_DEBUG="no"

	# Late variable binding - allow the package to now evaluate any variables
	# that we may have initialised after sourcing the package, typically
	# PKG_BUILD etc.
	if [ -n "${PKG_NAME}" ]; then
		if pkg_call_exists configure_package; then
			pkg_call configure_package
		fi
	fi
}

### KERNEL HELPERS ###
kernel_path()
{
	get_build_dir linux
}

kernel_version()
{
	get_pkg_version linux
}

kernel_config_path()
{
	local cfg pkg_linux_dir pkg_linux_version config_name

	pkg_linux_version="$(get_pkg_version linux)"
	pkg_linux_dir="$(get_pkg_directory linux)"

	config_name="linux.${TARGET_ARCH}.conf"

	for cfg in ${ROOT}/devices/${DEVICE}/linux/$pkg_linux_version/$config_name \
		${ROOT}/devices/${DEVICE}/linux/$LINUX/$config_name \
		${ROOT}/devices/${DEVICE}/linux/$config_name \
		${ROOT}/basis/linux/$pkg_linux_version/$config_name \
		${ROOT}/basis/linux/$LINUX/$config_name \
		${ROOT}/basis/linux/$config_name \
		$pkg_linux_dir/config/$pkg_linux_version/$config_name \
		$pkg_linux_dir/config/$LINUX/$config_name \
		$pkg_linux_dir/config/$config_name; do
		[[ $cfg =~ /devices//linux/ ]] && continue
		[ -f "$cfg" ] && echo "$cfg" && return
	done

	die "ERROR: Unable to locate kernel config for ${LINUX} - looking for ${config_name}"
}

kernel_make()
{
	(
		setup_pkg_config_host

		LDFLAGS="" make CROSS_COMPILE=$TARGET_KERNEL_PREFIX \
			ARCH="$TARGET_KERNEL_ARCH" \
			HOSTCC="$TOOLCHAIN/bin/host-gcc" \
			HOSTCXX="$TOOLCHAIN/bin/host-g++" \
			HOSTCFLAGS="$HOST_CFLAGS" \
			HOSTLDFLAGS="$HOST_LDFLAGS" \
			HOSTCXXFLAGS="$HOST_CXXFLAGS" \
			DEPMOD="$TOOLCHAIN/bin/depmod" \
			"$@"
	)
}

# get kernel module dir
get_module_dir()
{
	if [ -n "${_CACHED_KERNEL_MODULE_DIR}" ]; then
		echo "${_CACHED_KERNEL_MODULE_DIR}"
	else
		basename $(ls -d $(get_build_dir linux)/.install_pkg/usr/lib/kernel-overlays/base/lib/modules/*)
	fi
}

# get base path to kernel modules and firmware
get_kernel_overlay_dir()
{
	echo "usr/lib/kernel-overlays/${1:-base}"
}

# get full path to kernel module dir
# optional parameter specifies overlay level (default is base)
get_full_module_dir()
{
	echo "$(get_kernel_overlay_dir $1)/lib/modules/$(get_module_dir)"
}

# get full path to firmware dir
# optional parameter specifies overlay level (default is base)
get_full_firmware_dir()
{
	echo "$(get_kernel_overlay_dir $1)/lib/firmware"
}

fix_module_depends()
{
	# modify .modinfo section in kernel module to depends on other required modules
	local MODULE="$1"
	local DEPENDS="$2"
	local OLD_DEPENDS=""
	cp ${MODULE} ${MODULE}_orig
	$OBJDUMP -s -j .modinfo ${MODULE}_orig | awk 'BEGIN{v=0;} /Contents/ {v=1; next;} {if (v==1) print $0;}' >new.modinfo1
	cat new.modinfo1 | cut -c7-41 | awk '{printf($0);}' | sed 's/ //g;s/../\\\x&/g;' >new.modinfo2
	/bin/echo -ne $(cat new.modinfo2) | tr '\000' '\n' >new.modinfo3
	cat new.modinfo3 | awk '/^depends=/ {next;} {print $0;}' | tr '\n' '\000' >new.modinfo
	OLD_DEPENDS=$(awk '{FS="="} /depends=/ {print $2}' new.modinfo3)
	[ -n "$OLD_DEPENDS" ] && DEPENDS="$OLD_DEPENDS,$DEPENDS"
	/bin/echo -ne "depends=$DEPENDS\0" >>new.modinfo
	$OBJCOPY --remove-section=.modinfo --add-section=.modinfo=new.modinfo --set-section-flags .modinfo=contents,alloc,load,readonly,data ${MODULE}_orig ${MODULE}
	rm new.modinfo*
}

### TARGET CONFIGURATION HELPERS ###
add_user()
{
	# Usage: add_user "username" "password" "userid" "groupid" "description" "home" "shell"
	mkdir -p ${INSTALL}/etc
	touch ${INSTALL}/etc/passwd
	if ! grep -q "^$1:" ${INSTALL}/etc/passwd; then
		echo "$1:x:$3:$4:$5:$6:$7" >>${INSTALL}/etc/passwd
	fi

	mkdir -p ${INSTALL}/usr/cache
	touch ${INSTALL}/usr/cache/shadow
	ln -sf /home/.cache/shadow ${INSTALL}/etc/shadow 2>/dev/null || true

	PASSWORD="$2"
	if [ "$PASSWORD" = "x" ]; then
		PASSWORD="*"
	fi
	if ! grep -q "^$1:" ${INSTALL}/usr/cache/shadow; then
		echo "$1:$PASSWORD:::::::" >>${INSTALL}/usr/cache/shadow
	fi
}

add_group()
{
	# Usage: add_group "groupname" "groupid" ("members")
	mkdir -p ${INSTALL}/etc
	touch ${INSTALL}/etc/group
	if [ -z "$(grep "$1:" ${INSTALL}/etc/group)" ]; then
		echo "$1:x:$2:$3" >>${INSTALL}/etc/group
	fi
}

# Usage: enable_service <unit> [target]
enable_service()
{
	local unit="$1"
	local unit_dir="/usr/lib/systemd/system"
	local target="$2"
	local target_dir=$INSTALL

	[ -f "$target_dir/$unit_dir/$unit" ] || die
	if [ -z "$target" ]; then
		for target in $(grep '^WantedBy' $target_dir/$unit_dir/$unit | cut -f2 -d=); do
			if [ -n "$target" ]; then
				mkdir -p ${target_dir}/$unit_dir/${target}.wants
				ln -sf ../${unit} ${target_dir}/$unit_dir/${target}.wants/
			fi
		done
	fi
	for target in $(grep '^Alias' $target_dir/$unit_dir/$unit | cut -f2 -d=); do
		if [ -n "$target" ]; then
			ln -sf ${unit} ${target_dir}/$unit_dir/${target}
		fi
	done
}

### MULTI-THREADED FUNCTION HELPERS ###
# Test MTWITHLOCKS so that these functions are a no-op during non-multithreaded builds.

# Prevent concurrent modifications to a package (unpack) or
# package:target (install/build).
#
# If a package is already locked and the owner is ourselves
# then assume we already have the required lock.
pkg_lock()
{
	[ "${MTWITHLOCKS}" != "yes" ] && return 0

	local pkg="$1" task="$2" parent_pkg="$3"
	local this_job="${MTJOBID}"
	local lock_job lock_seq lock_task lock_pkg locked=no idwidth
	local fail_seq

	exec 98>"${BUILDER_THREADS}/locks/${pkg}.${task}"
	while [ : ]; do
		read -r lock_job lock_seq lock_task lock_pkg <<<$(cat "${BUILDER_THREADS}/locks/${pkg}.${task}.owner" 2>/dev/null)
		[ -n "${lock_job}" ] && break
		flock --wait 1 --exclusive 98 && locked=yes && break
	done

	if [ "${locked}" = "no" -a "${lock_job}/${lock_seq}" != "${this_job}/${PARALLEL_SEQ}" ]; then
		[ "${THREADCOUNT}" = "0" ] && idwidth=${#MTMAXJOBS} || idwidth=2
		pkg_lock_status "STALLED" "${parent_pkg}" "${task}" "$(printf "waiting on [%0*d] %s %s" ${idwidth} ${lock_job} "${lock_task}" "${lock_pkg}")"
		flock --exclusive 98
	fi

	# As we now have the lock, if .failed still exists then a previous process must have failed
	if [ -f "${BUILDER_THREADS}/locks/${pkg}.${task}.failed" ]; then
		fail_seq="$(<"${BUILDER_THREADS}/locks/${pkg}.${task}.failed")"
		print_color CLR_ERROR "FAILURE: ${pkg}.${task}.failed exists, a previous dependency process has failed (seq: ${fail_seq})\n"
		if [ -d "${BUILDER_THREADS}/logs" ]; then
			cat <<EOF

The following logs for this failure are available:
  stdout: ${BUILDER_THREADS}/logs/${fail_seq}/stdout
  stderr: ${BUILDER_THREADS}/logs/${fail_seq}/stderr

EOF
		fi
		return 1
	fi

	pkg_lock_status "LOCKED" "${pkg}" "${task}"
}

# Log additional information for a locked package.
pkg_lock_status()
{
	[ "${MTWITHLOCKS}" != "yes" ] && return 0

	local status="$1" pkg="$2" task="$3" msg="$4"
	local this_job="${MTJOBID}" line idwidth

	[ "${THREADCOUNT}" = "0" ] && idwidth=${#MTMAXJOBS} || idwidth=2

	(
		flock --exclusive 94

		printf -v line "%s: <%06d> [%0*d/%0*d] %-7s %-7s %-35s" \
			"$(date +%Y-%m-%d\ %H:%M:%S.%N)" $$ ${idwidth} ${this_job} ${#MTMAXJOBS} ${PARALLEL_SEQ:-0} "${status}" "${task}" "${pkg}"
		[ -n "${msg}" ] && line+=" (${msg})"

		echo "${line}" >>"${BUILDER_THREADS}/history"

		if [ "${DASHBOARD}" != "no" ]; then
			monitor "${status}" "${pkg}" "${task}" "${msg}"
		fi
	) 94>"${BUILDER_THREADS}/locks/.history"

	if [ "${status}" = "LOCKED" ]; then
		echo "${PARALLEL_SEQ}" >"${BUILDER_THREADS}/locks/${pkg}.${task}.failed"
		echo "${this_job} ${PARALLEL_SEQ} ${task} ${pkg}" >"${BUILDER_THREADS}/locks/${pkg}.${task}.owner"
	elif [ "${status}" = "UNLOCK" ]; then
		rm "${BUILDER_THREADS}/locks/${pkg}.${task}.owner"
		rm "${BUILDER_THREADS}/locks/${pkg}.${task}.failed"
	fi

	return 0
}

monitor()
{
	[ "${MTWITHLOCKS}" != "yes" ] && return 0

	local status="$1" pkg="$2" task="$3" msg="$4"
	local line sedline preamble num elapsed projdevarch
	local boldred boldgreen boldyellow endcolor idwidth

	sedline=$((MTJOBID + 2))

	[ "${THREADCOUNT}" = "0" ] && idwidth=${#MTMAXJOBS} || idwidth=2

	num=$(<"${BUILDER_THREADS}/status.max")
	if [ ${num} -lt ${sedline} ]; then
		echo ${sedline} >"${BUILDER_THREADS}/status.max"
		for i in $(seq $((num + 1)) ${sedline}); do echo "" >>"${BUILDER_THREADS}/status"; done
	fi

	num=$(<"${BUILDER_THREADS}/progress.prev")
	projdevarch="${DEVICE}/"
	projdevarch+="${TARGET_ARCH}"
	TZ=UTC0 printf -v elapsed "%(%H:%M:%S)T" $(($(date +%s) - MTBUILDSTART))
	printf -v preamble "Thread Monitor (%s) - %d of %d jobs completed, %s elapsed" "${projdevarch}" $((num + 1)) ${MTMAXJOBS} "${elapsed}"
	printf -v preamble "%b%-105s %s" "\e[2J\e[0;0H" "${preamble//\//\\/}" "$(date "+%Y-%m-%d %H:%M:%S")"

	if [ "${DISABLE_COLORS}" != "yes" ]; then
		boldred="\e[1;31m"
		boldgreen="\e[1;32m"
		boldyellow="\e[1;33m"
		white="\e[0;37m"
		endcolor="\e[0m"

		case "${status}" in
			IDLE) color="${white}" ;;
			STALLED) color="${boldyellow}" ;;
			MUTEX/W) color="${boldyellow}" ;;
			FAILED) color="${boldred}" ;;
			*) color="${boldgreen}" ;;
		esac
	fi

	printf -v line "[%0*d\/%0*d] %b%-7s%b %-7s %-35s" ${idwidth} ${MTJOBID} ${#MTMAXJOBS} ${PARALLEL_SEQ:-0} "${color}" "${status//\//\\/}" "${endcolor}" "${task}" "${pkg}"
	[ -n "${msg}" ] && line+=" ${msg//\//\\/}"

	sed -e "1s/.*/${preamble}/;${sedline}s/.*/${line}/" -i "${BUILDER_THREADS}/status"
}

# Thread concurrency helpers to avoid concurrency issues with some code,
# eg. when Python installs directly into $TOOLCHAIN.
acquire_exclusive_lock()
{
	[ "${MTWITHLOCKS}" != "yes" ] && return 0

	local pkg="$1" task="$2" lockfile="${3:-global}"
	local this_job="${MTJOBID}"
	local lock_job lock_seq lock_task lock_pkg locked=no idwidth

	exec 96>"${BUILDER_THREADS}/locks/.mutex.${lockfile}"
	while [ : ]; do
		read -r lock_job lock_seq lock_task lock_pkg <<<$(cat "${BUILDER_THREADS}/locks/.mutex.${lockfile}.owner" 2>/dev/null)
		[ -n "${lock_job}" ] && break
		flock --wait 1 --exclusive 96 && locked=yes && break
	done

	if [ "${locked}" = "no" -a "${lock_job}/${lock_seq}" != "${this_job}/${PARALLEL_SEQ}" ]; then
		[ "${THREADCOUNT}" = "0" ] && idwidth=${#MTMAXJOBS} || idwidth=2
		pkg_lock_status "MUTEX/W" "${pkg}" "${task}" "$(printf "mutex: %s; waiting on [%0*d] %s %s" "${lockfile}" ${idwidth} ${lock_job} "${lock_task}" "${lock_pkg}")"
		flock --exclusive 96
	fi

	pkg_lock_status "MUTEX" "${pkg}" "${task}" "mutex: ${lockfile}"

	echo "${this_job} ${PARALLEL_SEQ} ${task} ${pkg}" >"${BUILDER_THREADS}/locks/.mutex.${lockfile}.owner"
}

release_exclusive_lock()
{
	[ "${MTWITHLOCKS}" != "yes" ] && return 0

	local pkg="$1" task="$2" lockfile="${3:-global}"

	pkg_lock_status "ACTIVE" "${pkg}" "${task}"

	rm "${BUILDER_THREADS}/locks/.mutex.${lockfile}.owner"
	flock --unlock 96 2>/dev/null
}

# Execute single command using mutex
exec_thread_safe()
{
	local result
	acquire_exclusive_lock "${PKG_NAME:exec}" "execcmd"
	$@
	result=$?
	release_exclusive_lock "${PKG_NAME:exec}" "execcmd"
	return ${result}
}

get_graphicdrivers()
{

	# set defaults
	GALLIUM_DRIVERS=""
	DRI_DRIVERS=""
	XORG_DRIVERS=""
	LLVM_SUPPORT="no"
	VDPAU_SUPPORT="no"
	VAAPI_SUPPORT="no"
	V4L2_SUPPORT="no"

	if listcontains "${GRAPHIC_DRIVERS}" "vc4"; then
		GALLIUM_DRIVERS+=" vc4 v3d kmsro"
		V4L2_SUPPORT="yes"
		VAAPI_SUPPORT="no"
		VDPAU_SUPPORT="no"
	fi

	# remove duplicate entries
	GALLIUM_DRIVERS="$(echo ${GALLIUM_DRIVERS} | xargs -n1 | sort -u | xargs)"
	XORG_DRIVERS="$(echo ${XORG_DRIVERS} | xargs -n1 | sort -u | xargs)"
	DRI_DRIVERS="$(echo ${DRI_DRIVERS} | xargs -n1 | sort -u | xargs)"
}

show_config()
{
	# load graphic configuration
	get_graphicdrivers

	# clear the entire console content
	clear

	# build distro configuration content
	double_dashes=$(printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' =)
	simple_dashes=$(printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -)
	config_message="$config_message\n$double_dashes"
	config_message="$config_message\n $(tput bold)\e[34m$DISTRO_NAME\e[39m (\e[5m${DISTRO_VERSION} ${DISTRO_STATUS}\e[25m) Configuration$(tput sgr0)\n\n"

	# Build options
	config_message="$config_message\n\n Build options:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - CPU (ARCH):\t\t\t\t ${TARGET_CPU} ($TARGET_ARCH)"
	config_message="$config_message\n - FLOAT:\t\t\t\t ${TARGET_FLOAT}"
	config_message="$config_message\n - FPU:\t\t\t\t\t ${TARGET_FPU}"
	config_message="$config_message\n - CPU features:\t\t\t ${TARGET_FEATURES}"
	config_message="$config_message\n - LTO (Link Time Optimization) support: ${LTO_SUPPORT}"
	config_message="$config_message\n - GOLD (Google Linker) Support:\t ${GOLD_SUPPORT}"
	config_message="$config_message\n - LLVM support:\t\t\t ${LLVM_SUPPORT}"
	config_message="$config_message\n - DEBUG:\t\t\t\t ${DEBUG}"

	# Graphic configuration
	config_message="$config_message\n\n Graphic configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - OpenGL (GLX) support (provider):\t $OPENGL_SUPPORT ($OPENGL)"
	config_message="$config_message\n - OpenGLES support (provider):\t\t $OPENGLES_SUPPORT ($OPENGLES)"
	config_message="$config_message\n - uvesafb support:\t\t\t $UVESAFB_SUPPORT"

	# Hardware decoder support
	config_message="$config_message\n\n Hardware decoder configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - Kodi Player driver:\t\t\t $KODIPLAYER_DRIVER"
	config_message="$config_message\n - VAAPI Support:\t\t\t $VAAPI_SUPPORT"
	config_message="$config_message\n - VDPAU Support:\t\t\t $VDPAU_SUPPORT"

	# Input device configuration
	config_message="$config_message\n\n Input device configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - CEC Adapter support:\t\t\t $CEC_SUPPORT"
	config_message="$config_message\n - CEC Framework support:\t\t $CEC_FRAMEWORK_SUPPORT"

	# Misc. hardware configuration
	config_message="$config_message\n\n Misc. hardware configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - ALSA support:\t\t\t $ALSA_SUPPORT"
	config_message="$config_message\n - Pulseaudio support:\t\t\t $PULSEAUDIO_SUPPORT"
	config_message="$config_message\n - Bluetooth support:\t\t\t $BLUETOOTH_SUPPORT"
	for config_driver in $ADDITIONAL_DRIVERS; do
		config_message="$config_message\n - Include driver:\t\t\t $config_driver"
	done
	for config_firmware in $FIRMWARE; do
		config_message="$config_message\n - Include firmware:\t\t\t $config_firmware"
	done
	for config_modules in $INITRAMFS_MODULES; do
		config_message="$config_message\n - Initramfs modules:\t\t\t $config_modules"
	done

	# Network service configuration
	config_message="$config_message\n\n Network service configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - Avahi (Zeroconf) support:\t\t $AVAHI_DAEMON"
	config_message="$config_message\n - NFS mounting support:\t\t $NFS_SUPPORT"
	config_message="$config_message\n - SAMBA mounting support:\t\t $SAMBA_SUPPORT"
	config_message="$config_message\n - SAMBA server support:\t\t $SAMBA_SERVER"
	config_message="$config_message\n - SFTP server support:\t\t\t $SFTP_SERVER"
	config_message="$config_message\n - OpenVPN support:\t\t\t $OPENVPN_SUPPORT"
	config_message="$config_message\n - WireGuard support:\t\t\t $WIREGUARD_SUPPORT"

	# OS configuration
	config_message="$config_message\n\n OS configuration:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - Default ROOT Password:\t\t $ROOT_PASSWORD"
	config_message="$config_message\n - UDevil support:\t\t\t $UDEVIL"

	# Misc. Filesystems
	config_message="$config_message\n\n Misc. File systems:"
	config_message="$config_message\n$simple_dashes"
	config_message="$config_message\n - Swap Support:\t\t\t $SWAP_SUPPORT"
	if [ "$SWAP_SUPPORT" = "yes" ]; then
		config_message="$config_message\n   - Swap file default size:\t\t $SWAPFILESIZE"
	fi
	config_message="$config_message\n - exFAT Support (via Fuse):\t\t $EXFAT"
	config_message="$config_message\n - NTFS Support (via Fuse):\t\t $NTFS3G"
	config_message="$config_message\n - Install HFS Tools:\t\t\t $HFSTOOLS"

	# Kodi configuration
	config_message="$config_message\n\n Kodi configuration:"
	config_message="$config_message\n$simple_dashes"

	config_message="$config_message\n - Kodi version:\t\t\t $(get_pkg_version kodi)"
	config_message="$config_message\n - Kodi Blu-Ray support:\t\t $KODI_BLURAY_SUPPORT"
	if [ "$KODI_BLURAY_SUPPORT" = "yes" ]; then
		config_message="$config_message\n   - Bluray BD+ support:\t\t $BLURAY_BDPLUS_SUPPORT"
		config_message="$config_message\n   - Bluray AACS support:\t\t $BLURAY_AACS_SUPPORT"
	fi
	config_message="$config_message\n - Kodi DVDCSS support:\t\t\t $KODI_DVDCSS_SUPPORT"
	config_message="$config_message\n - Kodi Airplay support:\t\t $KODI_AIRPLAY_SUPPORT"
	config_message="$config_message\n - Kodi Airtunes support:\t\t $KODI_AIRTUNES_SUPPORT"
	config_message="$config_message\n - Kodi NFS support:\t\t\t $KODI_NFS_SUPPORT"
	config_message="$config_message\n - Kodi MySQL support:\t\t\t $KODI_MYSQL_SUPPORT"
	config_message="$config_message\n - Kodi Optical Drive support:\t\t $KODI_OPTICAL_SUPPORT"
	config_message="$config_message\n - Kodi SAMBA client support:\t\t $KODI_SAMBA_SUPPORT"
	config_message="$config_message\n - Kodi UPNP support:\t\t\t $KODI_UPNP_SUPPORT"
	config_message="$config_message\n - Kodi Webserver support:\t\t $KODI_WEBSERVER_SUPPORT"
	config_message="$config_message\n - Include extra fonts:\t\t\t $KODI_EXTRA_FONTS"

	config_message="$config_message\n$double_dashes"
	config_message="$config_message\n\n"
	echo -e "$config_message"

	if [ "${1}" != "" ]; then
		read -n 1 -p "Press any key to continue.." key
		echo
		if [ "$key" = 'n' ] || [ "$key" = 'q' ] || [ "$key" = 's' ]; then
			echo -e "\n\t> operation stopped by the user!\n"
			exit 1
		fi
	fi
}

# Check configuration
check_config

# export variables
set_vars

# If the package caches are unset, then populate them
init_package_cache

# set package metadata
source_package "${1}"

# This function is passed a list of package.csh paths to be processed.
# Each package.csh is sourced with relevant variables output in JSON format.
json_worker()
{
	local packages="$@"
	local pkgpath hierarchy exited

	exit() { exited=1; }

	. ${ROOT}/devices/options ""

	for pkgpath in ${packages}; do
		pkgpath="${pkgpath%%@*}"

		exited=0
		if ! source_package "${pkgpath}/package.csh" &>/dev/null; then
			unset -f exit
			die "$(print_color CLR_ERROR "FAILURE: sourcing package ${pkgpath}/package.csh")"
		fi

		[ ${exited} -eq 1 ] && continue

		[[ ${pkgpath} =~ ^${ROOT}/${PACKAGES}/ ]] && hierarchy="global" || hierarchy="local"

		cat <<EOF
  {
    "name": "${PKG_NAME}",
    "hierarchy": "${hierarchy}",
    "section": "${PKG_SECTION}",
    "bootstrap": "${PKG_DEPENDS_BOOTSTRAP}",
    "init": "${PKG_DEPENDS_INIT}",
    "host": "${PKG_DEPENDS_HOST}",
    "target": "${PKG_DEPENDS_TARGET}"
  },
EOF
	done
}

export -f json_worker

# This function is passed the build instruction for a single job.
# The function will run either "build <package>" or "install <package>".
# ${slot} is the job slot number, ie. 1-8 when THREADCOUNT=8.
# ${job} is the sequence within the total number of ${jobs}.
package_worker()
{
	local slot=$1 job=$2 jobs=$3 args="$4"
	local task pkgname result status

	export MTJOBID=${slot} MTMAXJOBS=${jobs}

	read -r task pkgname <<<"${args}"

	. ${ROOT}/devices/options "${pkgname}"

	[ ! -f "${BUILDER_THREADS}/parallel.pid" ] && echo "${PARALLEL_PID}" >"${BUILDER_THREADS}/parallel.pid"

	${CONFIG}/${task} ${pkgname} 2>&1 && result=0 || result=1

	(
		flock --exclusive 95
		[ ${result} -eq 0 ] && status="DONE" || status="FAIL"
		num=$(<"${BUILDER_THREADS}/progress")
		mv "${BUILDER_THREADS}/progress" "${BUILDER_THREADS}/progress.prev"
		num=$((num + 1))
		echo ${num} >"${BUILDER_THREADS}/progress"
		printf "[%0*d/%0*d] [%-4s] %-7s %s\n" ${#jobs} ${num} ${#jobs} ${jobs} "${status}" "${task}" "${pkgname}" >&2
	) 95>"${BUILDER_THREADS}/locks/.progress"

	if [ ${result} -eq 0 ]; then
		pkg_lock_status "IDLE"
	else
		pkg_lock_status "FAILED" "${pkgname}" "${task}"

		print_color CLR_ERROR "FAILURE: ${CONFIG}/${task} ${pkgname} has failed!\n"

		if [ -d "${BUILDER_THREADS}/logs" ]; then
			cat >&2 <<EOF

The following logs for this failure are available:
  stdout: ${BUILDER_THREADS}/logs/${job}/stdout
  stderr: ${BUILDER_THREADS}/logs/${job}/stderr

EOF
		fi
	fi

	return ${result}
}

export -f package_worker

start_multithread_build()
{
	local singlethread buildopts="--halt now,fail=1" result=0

	# init thread control folder
	rm -rf "${BUILDER_THREADS}"
	mkdir -p "${BUILDER_THREADS}/locks"
	echo -1 >"${BUILDER_THREADS}/progress.prev"
	echo 0 >"${BUILDER_THREADS}/progress"
	echo 0 >"${BUILDER_THREADS}/status.max"
	touch "${BUILDER_THREADS}/status"

	# Increase file descriptors if building one thread/package
	[ "${THREADCOUNT}" = "0" ] && ulimit -n ${ULIMITN:-10240}

	# Bootstrap GNU parallel
	MTWITHLOCKS=no ${CONFIG}/build parallel:host 2>&1 || die "Unable to bootstrap parallel package"

	# determine number of available slots for the given THREADCOUNT - optimise logging for single threaded builds
	[ $(seq 1 32 | ${TOOLCHAIN}/bin/parallel --plain --no-notice --max-procs ${THREADCOUNT} echo {%} | sort -n | tail -1) -eq 1 ] && singlethread=yes || singlethread=no

	# create a single log file by default for a single threaded build (or the builder is a masochist)
	if [ "${singlethread}" = "yes" -a "${ONELOG,,}" != "no" ] || [ "${ONELOG,,}" = "yes" ]; then
		buildopts+=" --ungroup"
	else
		mkdir -p "${BUILDER_THREADS}/logs"
		buildopts+=" --group --results ${BUILDER_THREADS}/logs/{#}/"
	fi

	# pipefail: return value of a pipeline is the value of the last (rightmost) command to exit with a non-zero status
	set -o pipefail

	cat ${_CACHE_PACKAGE_GLOBAL} ${_CACHE_PACKAGE_LOCAL} |
		${TOOLCHAIN}/bin/parallel --plain --no-notice --max-args 30 --halt now,fail=1 json_worker |
		${CONFIG}/tools/planner.py --no-reorder --show-needs --build ${@} >"${BUILDER_THREADS}"/plan || result=1

	if [ ${result} -eq 0 ]; then
		cat "${BUILDER_THREADS}"/plan | awk '{print $1 " " $2}' |
			MTBUILDSTART=$(date +%s) MTWITHLOCKS=yes ${TOOLCHAIN}/bin/parallel \
				--plain --no-notice --max-procs ${THREADCOUNT} --joblog="${BUILDER_THREADS}/joblog" --plus ${buildopts} \
				package_worker {%} {#} {##} {} || result=1
		rm -f "${BUILDER_THREADS}/parallel.pid"
	fi

	set +o pipefail

	return ${result}
}

########################################################################################
